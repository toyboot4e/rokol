/* automatically generated by rust-bindgen 0.58.1 */

//! Rust FFI to [sokol_gfx.h](https://github.com/floooh/sokol/blob/master/sokol_gfx.h)

#![allow(warnings)]

pub const SOKOL_GFX_INCLUDED: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = u128;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __darwin_pthread_handler_rec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_attr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_cond_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_mutex_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_rwlock_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sg_buffer {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_sg_buffer() {
    assert_eq!(
        ::std::mem::size_of::<sg_buffer>(),
        4usize,
        concat!("Size of: ", stringify!(sg_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_buffer>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sg_image {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_sg_image() {
    assert_eq!(
        ::std::mem::size_of::<sg_image>(),
        4usize,
        concat!("Size of: ", stringify!(sg_image))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_image>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_image))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sg_shader {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_sg_shader() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader>(),
        4usize,
        concat!("Size of: ", stringify!(sg_shader))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_shader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sg_pipeline {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_sg_pipeline() {
    assert_eq!(
        ::std::mem::size_of::<sg_pipeline>(),
        4usize,
        concat!("Size of: ", stringify!(sg_pipeline))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pipeline>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_pipeline))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sg_pass {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_sg_pass() {
    assert_eq!(
        ::std::mem::size_of::<sg_pass>(),
        4usize,
        concat!("Size of: ", stringify!(sg_pass))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pass>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_pass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sg_context {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_sg_context() {
    assert_eq!(
        ::std::mem::size_of::<sg_context>(),
        4usize,
        concat!("Size of: ", stringify!(sg_context))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_context>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_range {
    pub ptr: *const ::std::os::raw::c_void,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_sg_range() {
    assert_eq!(
        ::std::mem::size_of::<sg_range>(),
        16usize,
        concat!("Size of: ", stringify!(sg_range))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_range>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_range>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_range),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_range>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_range),
            "::",
            stringify!(size)
        )
    );
}
impl Default for sg_range {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const SG_INVALID_ID: _bindgen_ty_1 = _bindgen_ty_1::SG_INVALID_ID;
pub const SG_NUM_SHADER_STAGES: _bindgen_ty_1 = _bindgen_ty_1::SG_NUM_SHADER_STAGES;
pub const SG_NUM_INFLIGHT_FRAMES: _bindgen_ty_1 = _bindgen_ty_1::SG_NUM_SHADER_STAGES;
pub const SG_MAX_COLOR_ATTACHMENTS: _bindgen_ty_1 = _bindgen_ty_1::SG_MAX_COLOR_ATTACHMENTS;
pub const SG_MAX_SHADERSTAGE_BUFFERS: _bindgen_ty_1 = _bindgen_ty_1::SG_MAX_SHADERSTAGE_BUFFERS;
pub const SG_MAX_SHADERSTAGE_IMAGES: _bindgen_ty_1 = _bindgen_ty_1::SG_MAX_SHADERSTAGE_IMAGES;
pub const SG_MAX_SHADERSTAGE_UBS: _bindgen_ty_1 = _bindgen_ty_1::SG_MAX_COLOR_ATTACHMENTS;
pub const SG_MAX_UB_MEMBERS: _bindgen_ty_1 = _bindgen_ty_1::SG_MAX_UB_MEMBERS;
pub const SG_MAX_VERTEX_ATTRIBUTES: _bindgen_ty_1 = _bindgen_ty_1::SG_MAX_UB_MEMBERS;
pub const SG_MAX_MIPMAPS: _bindgen_ty_1 = _bindgen_ty_1::SG_MAX_UB_MEMBERS;
pub const SG_MAX_TEXTUREARRAY_LAYERS: _bindgen_ty_1 = _bindgen_ty_1::SG_MAX_TEXTUREARRAY_LAYERS;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    SG_INVALID_ID = 0,
    SG_NUM_SHADER_STAGES = 2,
    SG_MAX_COLOR_ATTACHMENTS = 4,
    SG_MAX_SHADERSTAGE_BUFFERS = 8,
    SG_MAX_SHADERSTAGE_IMAGES = 12,
    SG_MAX_UB_MEMBERS = 16,
    SG_MAX_TEXTUREARRAY_LAYERS = 128,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq)]
pub struct sg_color {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}
#[test]
fn bindgen_test_layout_sg_color() {
    assert_eq!(
        ::std::mem::size_of::<sg_color>(),
        16usize,
        concat!("Size of: ", stringify!(sg_color))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_color>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_color))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_color>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_color),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_color>())).g as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_color),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_color>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_color),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_color>())).a as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_color),
            "::",
            stringify!(a)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_backend {
    SG_BACKEND_GLCORE33 = 0,
    SG_BACKEND_GLES2 = 1,
    SG_BACKEND_GLES3 = 2,
    SG_BACKEND_D3D11 = 3,
    SG_BACKEND_METAL_IOS = 4,
    SG_BACKEND_METAL_MACOS = 5,
    SG_BACKEND_METAL_SIMULATOR = 6,
    SG_BACKEND_WGPU = 7,
    SG_BACKEND_DUMMY = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_pixel_format {
    _SG_PIXELFORMAT_DEFAULT = 0,
    SG_PIXELFORMAT_NONE = 1,
    SG_PIXELFORMAT_R8 = 2,
    SG_PIXELFORMAT_R8SN = 3,
    SG_PIXELFORMAT_R8UI = 4,
    SG_PIXELFORMAT_R8SI = 5,
    SG_PIXELFORMAT_R16 = 6,
    SG_PIXELFORMAT_R16SN = 7,
    SG_PIXELFORMAT_R16UI = 8,
    SG_PIXELFORMAT_R16SI = 9,
    SG_PIXELFORMAT_R16F = 10,
    SG_PIXELFORMAT_RG8 = 11,
    SG_PIXELFORMAT_RG8SN = 12,
    SG_PIXELFORMAT_RG8UI = 13,
    SG_PIXELFORMAT_RG8SI = 14,
    SG_PIXELFORMAT_R32UI = 15,
    SG_PIXELFORMAT_R32SI = 16,
    SG_PIXELFORMAT_R32F = 17,
    SG_PIXELFORMAT_RG16 = 18,
    SG_PIXELFORMAT_RG16SN = 19,
    SG_PIXELFORMAT_RG16UI = 20,
    SG_PIXELFORMAT_RG16SI = 21,
    SG_PIXELFORMAT_RG16F = 22,
    SG_PIXELFORMAT_RGBA8 = 23,
    SG_PIXELFORMAT_RGBA8SN = 24,
    SG_PIXELFORMAT_RGBA8UI = 25,
    SG_PIXELFORMAT_RGBA8SI = 26,
    SG_PIXELFORMAT_BGRA8 = 27,
    SG_PIXELFORMAT_RGB10A2 = 28,
    SG_PIXELFORMAT_RG11B10F = 29,
    SG_PIXELFORMAT_RG32UI = 30,
    SG_PIXELFORMAT_RG32SI = 31,
    SG_PIXELFORMAT_RG32F = 32,
    SG_PIXELFORMAT_RGBA16 = 33,
    SG_PIXELFORMAT_RGBA16SN = 34,
    SG_PIXELFORMAT_RGBA16UI = 35,
    SG_PIXELFORMAT_RGBA16SI = 36,
    SG_PIXELFORMAT_RGBA16F = 37,
    SG_PIXELFORMAT_RGBA32UI = 38,
    SG_PIXELFORMAT_RGBA32SI = 39,
    SG_PIXELFORMAT_RGBA32F = 40,
    SG_PIXELFORMAT_DEPTH = 41,
    SG_PIXELFORMAT_DEPTH_STENCIL = 42,
    SG_PIXELFORMAT_BC1_RGBA = 43,
    SG_PIXELFORMAT_BC2_RGBA = 44,
    SG_PIXELFORMAT_BC3_RGBA = 45,
    SG_PIXELFORMAT_BC4_R = 46,
    SG_PIXELFORMAT_BC4_RSN = 47,
    SG_PIXELFORMAT_BC5_RG = 48,
    SG_PIXELFORMAT_BC5_RGSN = 49,
    SG_PIXELFORMAT_BC6H_RGBF = 50,
    SG_PIXELFORMAT_BC6H_RGBUF = 51,
    SG_PIXELFORMAT_BC7_RGBA = 52,
    SG_PIXELFORMAT_PVRTC_RGB_2BPP = 53,
    SG_PIXELFORMAT_PVRTC_RGB_4BPP = 54,
    SG_PIXELFORMAT_PVRTC_RGBA_2BPP = 55,
    SG_PIXELFORMAT_PVRTC_RGBA_4BPP = 56,
    SG_PIXELFORMAT_ETC2_RGB8 = 57,
    SG_PIXELFORMAT_ETC2_RGB8A1 = 58,
    SG_PIXELFORMAT_ETC2_RGBA8 = 59,
    SG_PIXELFORMAT_ETC2_RG11 = 60,
    SG_PIXELFORMAT_ETC2_RG11SN = 61,
    _SG_PIXELFORMAT_NUM = 62,
    _SG_PIXELFORMAT_FORCE_U32 = 2147483647,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sg_pixelformat_info {
    pub sample: bool,
    pub filter: bool,
    pub render: bool,
    pub blend: bool,
    pub msaa: bool,
    pub depth: bool,
}
#[test]
fn bindgen_test_layout_sg_pixelformat_info() {
    assert_eq!(
        ::std::mem::size_of::<sg_pixelformat_info>(),
        6usize,
        concat!("Size of: ", stringify!(sg_pixelformat_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pixelformat_info>(),
        1usize,
        concat!("Alignment of ", stringify!(sg_pixelformat_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pixelformat_info>())).sample as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pixelformat_info),
            "::",
            stringify!(sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pixelformat_info>())).filter as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pixelformat_info),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pixelformat_info>())).render as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pixelformat_info),
            "::",
            stringify!(render)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pixelformat_info>())).blend as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pixelformat_info),
            "::",
            stringify!(blend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pixelformat_info>())).msaa as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pixelformat_info),
            "::",
            stringify!(msaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pixelformat_info>())).depth as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pixelformat_info),
            "::",
            stringify!(depth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sg_features {
    pub instancing: bool,
    pub origin_top_left: bool,
    pub multiple_render_targets: bool,
    pub msaa_render_targets: bool,
    pub imagetype_3d: bool,
    pub imagetype_array: bool,
    pub image_clamp_to_border: bool,
    pub mrt_independent_blend_state: bool,
    pub mrt_independent_write_mask: bool,
}
#[test]
fn bindgen_test_layout_sg_features() {
    assert_eq!(
        ::std::mem::size_of::<sg_features>(),
        9usize,
        concat!("Size of: ", stringify!(sg_features))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_features>(),
        1usize,
        concat!("Alignment of ", stringify!(sg_features))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_features>())).instancing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(instancing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_features>())).origin_top_left as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(origin_top_left)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_features>())).multiple_render_targets as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(multiple_render_targets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_features>())).msaa_render_targets as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(msaa_render_targets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_features>())).imagetype_3d as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(imagetype_3d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_features>())).imagetype_array as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(imagetype_array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_features>())).image_clamp_to_border as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(image_clamp_to_border)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_features>())).mrt_independent_blend_state as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(mrt_independent_blend_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_features>())).mrt_independent_write_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(mrt_independent_write_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sg_limits {
    pub max_image_size_2d: ::std::os::raw::c_int,
    pub max_image_size_cube: ::std::os::raw::c_int,
    pub max_image_size_3d: ::std::os::raw::c_int,
    pub max_image_size_array: ::std::os::raw::c_int,
    pub max_image_array_layers: ::std::os::raw::c_int,
    pub max_vertex_attrs: ::std::os::raw::c_int,
    pub gl_max_vertex_uniform_vectors: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sg_limits() {
    assert_eq!(
        ::std::mem::size_of::<sg_limits>(),
        28usize,
        concat!("Size of: ", stringify!(sg_limits))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_limits>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_limits))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_limits>())).max_image_size_2d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_limits),
            "::",
            stringify!(max_image_size_2d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_limits>())).max_image_size_cube as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_limits),
            "::",
            stringify!(max_image_size_cube)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_limits>())).max_image_size_3d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_limits),
            "::",
            stringify!(max_image_size_3d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_limits>())).max_image_size_array as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_limits),
            "::",
            stringify!(max_image_size_array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_limits>())).max_image_array_layers as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_limits),
            "::",
            stringify!(max_image_array_layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_limits>())).max_vertex_attrs as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_limits),
            "::",
            stringify!(max_vertex_attrs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_limits>())).gl_max_vertex_uniform_vectors as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_limits),
            "::",
            stringify!(gl_max_vertex_uniform_vectors)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_resource_state {
    SG_RESOURCESTATE_INITIAL = 0,
    SG_RESOURCESTATE_ALLOC = 1,
    SG_RESOURCESTATE_VALID = 2,
    SG_RESOURCESTATE_FAILED = 3,
    SG_RESOURCESTATE_INVALID = 4,
    _SG_RESOURCESTATE_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_usage {
    _SG_USAGE_DEFAULT = 0,
    SG_USAGE_IMMUTABLE = 1,
    SG_USAGE_DYNAMIC = 2,
    SG_USAGE_STREAM = 3,
    _SG_USAGE_NUM = 4,
    _SG_USAGE_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_buffer_type {
    _SG_BUFFERTYPE_DEFAULT = 0,
    SG_BUFFERTYPE_VERTEXBUFFER = 1,
    SG_BUFFERTYPE_INDEXBUFFER = 2,
    _SG_BUFFERTYPE_NUM = 3,
    _SG_BUFFERTYPE_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_index_type {
    _SG_INDEXTYPE_DEFAULT = 0,
    SG_INDEXTYPE_NONE = 1,
    SG_INDEXTYPE_UINT16 = 2,
    SG_INDEXTYPE_UINT32 = 3,
    _SG_INDEXTYPE_NUM = 4,
    _SG_INDEXTYPE_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_image_type {
    _SG_IMAGETYPE_DEFAULT = 0,
    SG_IMAGETYPE_2D = 1,
    SG_IMAGETYPE_CUBE = 2,
    SG_IMAGETYPE_3D = 3,
    SG_IMAGETYPE_ARRAY = 4,
    _SG_IMAGETYPE_NUM = 5,
    _SG_IMAGETYPE_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_sampler_type {
    _SG_SAMPLERTYPE_DEFAULT = 0,
    SG_SAMPLERTYPE_FLOAT = 1,
    SG_SAMPLERTYPE_SINT = 2,
    SG_SAMPLERTYPE_UINT = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_cube_face {
    SG_CUBEFACE_POS_X = 0,
    SG_CUBEFACE_NEG_X = 1,
    SG_CUBEFACE_POS_Y = 2,
    SG_CUBEFACE_NEG_Y = 3,
    SG_CUBEFACE_POS_Z = 4,
    SG_CUBEFACE_NEG_Z = 5,
    SG_CUBEFACE_NUM = 6,
    _SG_CUBEFACE_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_shader_stage {
    SG_SHADERSTAGE_VS = 0,
    SG_SHADERSTAGE_FS = 1,
    _SG_SHADERSTAGE_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_primitive_type {
    _SG_PRIMITIVETYPE_DEFAULT = 0,
    SG_PRIMITIVETYPE_POINTS = 1,
    SG_PRIMITIVETYPE_LINES = 2,
    SG_PRIMITIVETYPE_LINE_STRIP = 3,
    SG_PRIMITIVETYPE_TRIANGLES = 4,
    SG_PRIMITIVETYPE_TRIANGLE_STRIP = 5,
    _SG_PRIMITIVETYPE_NUM = 6,
    _SG_PRIMITIVETYPE_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_filter {
    _SG_FILTER_DEFAULT = 0,
    SG_FILTER_NEAREST = 1,
    SG_FILTER_LINEAR = 2,
    SG_FILTER_NEAREST_MIPMAP_NEAREST = 3,
    SG_FILTER_NEAREST_MIPMAP_LINEAR = 4,
    SG_FILTER_LINEAR_MIPMAP_NEAREST = 5,
    SG_FILTER_LINEAR_MIPMAP_LINEAR = 6,
    _SG_FILTER_NUM = 7,
    _SG_FILTER_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_wrap {
    _SG_WRAP_DEFAULT = 0,
    SG_WRAP_REPEAT = 1,
    SG_WRAP_CLAMP_TO_EDGE = 2,
    SG_WRAP_CLAMP_TO_BORDER = 3,
    SG_WRAP_MIRRORED_REPEAT = 4,
    _SG_WRAP_NUM = 5,
    _SG_WRAP_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_border_color {
    _SG_BORDERCOLOR_DEFAULT = 0,
    SG_BORDERCOLOR_TRANSPARENT_BLACK = 1,
    SG_BORDERCOLOR_OPAQUE_BLACK = 2,
    SG_BORDERCOLOR_OPAQUE_WHITE = 3,
    _SG_BORDERCOLOR_NUM = 4,
    _SG_BORDERCOLOR_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_vertex_format {
    SG_VERTEXFORMAT_INVALID = 0,
    SG_VERTEXFORMAT_FLOAT = 1,
    SG_VERTEXFORMAT_FLOAT2 = 2,
    SG_VERTEXFORMAT_FLOAT3 = 3,
    SG_VERTEXFORMAT_FLOAT4 = 4,
    SG_VERTEXFORMAT_BYTE4 = 5,
    SG_VERTEXFORMAT_BYTE4N = 6,
    SG_VERTEXFORMAT_UBYTE4 = 7,
    SG_VERTEXFORMAT_UBYTE4N = 8,
    SG_VERTEXFORMAT_SHORT2 = 9,
    SG_VERTEXFORMAT_SHORT2N = 10,
    SG_VERTEXFORMAT_USHORT2N = 11,
    SG_VERTEXFORMAT_SHORT4 = 12,
    SG_VERTEXFORMAT_SHORT4N = 13,
    SG_VERTEXFORMAT_USHORT4N = 14,
    SG_VERTEXFORMAT_UINT10_N2 = 15,
    _SG_VERTEXFORMAT_NUM = 16,
    _SG_VERTEXFORMAT_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_vertex_step {
    _SG_VERTEXSTEP_DEFAULT = 0,
    SG_VERTEXSTEP_PER_VERTEX = 1,
    SG_VERTEXSTEP_PER_INSTANCE = 2,
    _SG_VERTEXSTEP_NUM = 3,
    _SG_VERTEXSTEP_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_uniform_type {
    SG_UNIFORMTYPE_INVALID = 0,
    SG_UNIFORMTYPE_FLOAT = 1,
    SG_UNIFORMTYPE_FLOAT2 = 2,
    SG_UNIFORMTYPE_FLOAT3 = 3,
    SG_UNIFORMTYPE_FLOAT4 = 4,
    SG_UNIFORMTYPE_MAT4 = 5,
    _SG_UNIFORMTYPE_NUM = 6,
    _SG_UNIFORMTYPE_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_cull_mode {
    _SG_CULLMODE_DEFAULT = 0,
    SG_CULLMODE_NONE = 1,
    SG_CULLMODE_FRONT = 2,
    SG_CULLMODE_BACK = 3,
    _SG_CULLMODE_NUM = 4,
    _SG_CULLMODE_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_face_winding {
    _SG_FACEWINDING_DEFAULT = 0,
    SG_FACEWINDING_CCW = 1,
    SG_FACEWINDING_CW = 2,
    _SG_FACEWINDING_NUM = 3,
    _SG_FACEWINDING_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_compare_func {
    _SG_COMPAREFUNC_DEFAULT = 0,
    SG_COMPAREFUNC_NEVER = 1,
    SG_COMPAREFUNC_LESS = 2,
    SG_COMPAREFUNC_EQUAL = 3,
    SG_COMPAREFUNC_LESS_EQUAL = 4,
    SG_COMPAREFUNC_GREATER = 5,
    SG_COMPAREFUNC_NOT_EQUAL = 6,
    SG_COMPAREFUNC_GREATER_EQUAL = 7,
    SG_COMPAREFUNC_ALWAYS = 8,
    _SG_COMPAREFUNC_NUM = 9,
    _SG_COMPAREFUNC_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_stencil_op {
    _SG_STENCILOP_DEFAULT = 0,
    SG_STENCILOP_KEEP = 1,
    SG_STENCILOP_ZERO = 2,
    SG_STENCILOP_REPLACE = 3,
    SG_STENCILOP_INCR_CLAMP = 4,
    SG_STENCILOP_DECR_CLAMP = 5,
    SG_STENCILOP_INVERT = 6,
    SG_STENCILOP_INCR_WRAP = 7,
    SG_STENCILOP_DECR_WRAP = 8,
    _SG_STENCILOP_NUM = 9,
    _SG_STENCILOP_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_blend_factor {
    _SG_BLENDFACTOR_DEFAULT = 0,
    SG_BLENDFACTOR_ZERO = 1,
    SG_BLENDFACTOR_ONE = 2,
    SG_BLENDFACTOR_SRC_COLOR = 3,
    SG_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 4,
    SG_BLENDFACTOR_SRC_ALPHA = 5,
    SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 6,
    SG_BLENDFACTOR_DST_COLOR = 7,
    SG_BLENDFACTOR_ONE_MINUS_DST_COLOR = 8,
    SG_BLENDFACTOR_DST_ALPHA = 9,
    SG_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 10,
    SG_BLENDFACTOR_SRC_ALPHA_SATURATED = 11,
    SG_BLENDFACTOR_BLEND_COLOR = 12,
    SG_BLENDFACTOR_ONE_MINUS_BLEND_COLOR = 13,
    SG_BLENDFACTOR_BLEND_ALPHA = 14,
    SG_BLENDFACTOR_ONE_MINUS_BLEND_ALPHA = 15,
    _SG_BLENDFACTOR_NUM = 16,
    _SG_BLENDFACTOR_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_blend_op {
    _SG_BLENDOP_DEFAULT = 0,
    SG_BLENDOP_ADD = 1,
    SG_BLENDOP_SUBTRACT = 2,
    SG_BLENDOP_REVERSE_SUBTRACT = 3,
    _SG_BLENDOP_NUM = 4,
    _SG_BLENDOP_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_color_mask {
    _SG_COLORMASK_DEFAULT = 0,
    SG_COLORMASK_NONE = 16,
    SG_COLORMASK_R = 1,
    SG_COLORMASK_G = 2,
    SG_COLORMASK_RG = 3,
    SG_COLORMASK_B = 4,
    SG_COLORMASK_RB = 5,
    SG_COLORMASK_GB = 6,
    SG_COLORMASK_RGB = 7,
    SG_COLORMASK_A = 8,
    SG_COLORMASK_RA = 9,
    SG_COLORMASK_GA = 10,
    SG_COLORMASK_RGA = 11,
    SG_COLORMASK_BA = 12,
    SG_COLORMASK_RBA = 13,
    SG_COLORMASK_GBA = 14,
    SG_COLORMASK_RGBA = 15,
    _SG_COLORMASK_FORCE_U32 = 2147483647,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sg_action {
    _SG_ACTION_DEFAULT = 0,
    SG_ACTION_CLEAR = 1,
    SG_ACTION_LOAD = 2,
    SG_ACTION_DONTCARE = 3,
    _SG_ACTION_NUM = 4,
    _SG_ACTION_FORCE_U32 = 2147483647,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct sg_color_attachment_action {
    pub action: sg_action,
    pub value: sg_color,
}
#[test]
fn bindgen_test_layout_sg_color_attachment_action() {
    assert_eq!(
        ::std::mem::size_of::<sg_color_attachment_action>(),
        20usize,
        concat!("Size of: ", stringify!(sg_color_attachment_action))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_color_attachment_action>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_color_attachment_action))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_color_attachment_action>())).action as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_color_attachment_action),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_color_attachment_action>())).value as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_color_attachment_action),
            "::",
            stringify!(value)
        )
    );
}
impl Default for sg_color_attachment_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct sg_depth_attachment_action {
    pub action: sg_action,
    pub value: f32,
}
#[test]
fn bindgen_test_layout_sg_depth_attachment_action() {
    assert_eq!(
        ::std::mem::size_of::<sg_depth_attachment_action>(),
        8usize,
        concat!("Size of: ", stringify!(sg_depth_attachment_action))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_depth_attachment_action>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_depth_attachment_action))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_depth_attachment_action>())).action as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_attachment_action),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_depth_attachment_action>())).value as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_attachment_action),
            "::",
            stringify!(value)
        )
    );
}
impl Default for sg_depth_attachment_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_stencil_attachment_action {
    pub action: sg_action,
    pub value: u8,
}
#[test]
fn bindgen_test_layout_sg_stencil_attachment_action() {
    assert_eq!(
        ::std::mem::size_of::<sg_stencil_attachment_action>(),
        8usize,
        concat!("Size of: ", stringify!(sg_stencil_attachment_action))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_stencil_attachment_action>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_stencil_attachment_action))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_stencil_attachment_action>())).action as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_attachment_action),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_stencil_attachment_action>())).value as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_attachment_action),
            "::",
            stringify!(value)
        )
    );
}
impl Default for sg_stencil_attachment_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct sg_pass_action {
    pub _start_canary: u32,
    pub colors: [sg_color_attachment_action; 4usize],
    pub depth: sg_depth_attachment_action,
    pub stencil: sg_stencil_attachment_action,
    pub _end_canary: u32,
}
#[test]
fn bindgen_test_layout_sg_pass_action() {
    assert_eq!(
        ::std::mem::size_of::<sg_pass_action>(),
        104usize,
        concat!("Size of: ", stringify!(sg_pass_action))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pass_action>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_pass_action))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_action>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_action),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_action>())).colors as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_action),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_action>())).depth as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_action),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_action>())).stencil as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_action),
            "::",
            stringify!(stencil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_action>()))._end_canary as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_action),
            "::",
            stringify!(_end_canary)
        )
    );
}
impl Default for sg_pass_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sg_bindings {
    pub _start_canary: u32,
    pub vertex_buffers: [sg_buffer; 8usize],
    pub vertex_buffer_offsets: [::std::os::raw::c_int; 8usize],
    pub index_buffer: sg_buffer,
    pub index_buffer_offset: ::std::os::raw::c_int,
    pub vs_images: [sg_image; 12usize],
    pub fs_images: [sg_image; 12usize],
    pub _end_canary: u32,
}
#[test]
fn bindgen_test_layout_sg_bindings() {
    assert_eq!(
        ::std::mem::size_of::<sg_bindings>(),
        176usize,
        concat!("Size of: ", stringify!(sg_bindings))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_bindings>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_bindings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_bindings>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_bindings>())).vertex_buffers as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(vertex_buffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_bindings>())).vertex_buffer_offsets as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(vertex_buffer_offsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_bindings>())).index_buffer as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(index_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_bindings>())).index_buffer_offset as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(index_buffer_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_bindings>())).vs_images as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(vs_images)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_bindings>())).fs_images as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(fs_images)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_bindings>()))._end_canary as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(_end_canary)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_buffer_desc {
    pub _start_canary: u32,
    pub size: size_t,
    pub type_: sg_buffer_type,
    pub usage: sg_usage,
    pub data: sg_range,
    pub label: *const ::std::os::raw::c_char,
    pub gl_buffers: [u32; 2usize],
    pub mtl_buffers: [*const ::std::os::raw::c_void; 2usize],
    pub d3d11_buffer: *const ::std::os::raw::c_void,
    pub wgpu_buffer: *const ::std::os::raw::c_void,
    pub _end_canary: u32,
}
#[test]
fn bindgen_test_layout_sg_buffer_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_buffer_desc>(),
        96usize,
        concat!("Size of: ", stringify!(sg_buffer_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_buffer_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_buffer_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).usage as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).label as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).gl_buffers as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(gl_buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).mtl_buffers as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(mtl_buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).d3d11_buffer as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(d3d11_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).wgpu_buffer as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(wgpu_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>()))._end_canary as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(_end_canary)
        )
    );
}
impl Default for sg_buffer_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_image_data {
    pub subimage: [[sg_range; 16usize]; 6usize],
}
#[test]
fn bindgen_test_layout_sg_image_data() {
    assert_eq!(
        ::std::mem::size_of::<sg_image_data>(),
        1536usize,
        concat!("Size of: ", stringify!(sg_image_data))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_image_data>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_image_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_data>())).subimage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_data),
            "::",
            stringify!(subimage)
        )
    );
}
impl Default for sg_image_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct sg_image_desc {
    pub _start_canary: u32,
    pub type_: sg_image_type,
    pub render_target: bool,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub num_slices: ::std::os::raw::c_int,
    pub num_mipmaps: ::std::os::raw::c_int,
    pub usage: sg_usage,
    pub pixel_format: sg_pixel_format,
    pub sample_count: ::std::os::raw::c_int,
    pub min_filter: sg_filter,
    pub mag_filter: sg_filter,
    pub wrap_u: sg_wrap,
    pub wrap_v: sg_wrap,
    pub wrap_w: sg_wrap,
    pub border_color: sg_border_color,
    pub max_anisotropy: u32,
    pub min_lod: f32,
    pub max_lod: f32,
    pub data: sg_image_data,
    pub label: *const ::std::os::raw::c_char,
    pub gl_textures: [u32; 2usize],
    pub gl_texture_target: u32,
    pub mtl_textures: [*const ::std::os::raw::c_void; 2usize],
    pub d3d11_texture: *const ::std::os::raw::c_void,
    pub d3d11_shader_resource_view: *const ::std::os::raw::c_void,
    pub wgpu_texture: *const ::std::os::raw::c_void,
    pub _end_canary: u32,
}
#[test]
fn bindgen_test_layout_sg_image_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_image_desc>(),
        1688usize,
        concat!("Size of: ", stringify!(sg_image_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_image_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_image_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).render_target as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(render_target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).num_slices as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(num_slices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).num_mipmaps as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(num_mipmaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).usage as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).pixel_format as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).sample_count as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(sample_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).min_filter as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(min_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).mag_filter as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(mag_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).wrap_u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(wrap_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).wrap_v as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(wrap_v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).wrap_w as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(wrap_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).border_color as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(border_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).max_anisotropy as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(max_anisotropy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).min_lod as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(min_lod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).max_lod as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(max_lod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).data as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).label as *const _ as usize },
        1616usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).gl_textures as *const _ as usize },
        1624usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(gl_textures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).gl_texture_target as *const _ as usize },
        1632usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(gl_texture_target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).mtl_textures as *const _ as usize },
        1640usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(mtl_textures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).d3d11_texture as *const _ as usize },
        1656usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(d3d11_texture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_image_desc>())).d3d11_shader_resource_view as *const _
                as usize
        },
        1664usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(d3d11_shader_resource_view)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).wgpu_texture as *const _ as usize },
        1672usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(wgpu_texture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>()))._end_canary as *const _ as usize },
        1680usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(_end_canary)
        )
    );
}
impl Default for sg_image_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_shader_attr_desc {
    pub name: *const ::std::os::raw::c_char,
    pub sem_name: *const ::std::os::raw::c_char,
    pub sem_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sg_shader_attr_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader_attr_desc>(),
        24usize,
        concat!("Size of: ", stringify!(sg_shader_attr_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader_attr_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_shader_attr_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_attr_desc>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_attr_desc),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_attr_desc>())).sem_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_attr_desc),
            "::",
            stringify!(sem_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_attr_desc>())).sem_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_attr_desc),
            "::",
            stringify!(sem_index)
        )
    );
}
impl Default for sg_shader_attr_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_shader_uniform_desc {
    pub name: *const ::std::os::raw::c_char,
    pub type_: sg_uniform_type,
    pub array_count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sg_shader_uniform_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader_uniform_desc>(),
        16usize,
        concat!("Size of: ", stringify!(sg_shader_uniform_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader_uniform_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_shader_uniform_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_uniform_desc>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_uniform_desc),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_uniform_desc>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_uniform_desc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_shader_uniform_desc>())).array_count as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_uniform_desc),
            "::",
            stringify!(array_count)
        )
    );
}
impl Default for sg_shader_uniform_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_shader_uniform_block_desc {
    pub size: size_t,
    pub uniforms: [sg_shader_uniform_desc; 16usize],
}
#[test]
fn bindgen_test_layout_sg_shader_uniform_block_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader_uniform_block_desc>(),
        264usize,
        concat!("Size of: ", stringify!(sg_shader_uniform_block_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader_uniform_block_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_shader_uniform_block_desc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_shader_uniform_block_desc>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_uniform_block_desc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_shader_uniform_block_desc>())).uniforms as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_uniform_block_desc),
            "::",
            stringify!(uniforms)
        )
    );
}
impl Default for sg_shader_uniform_block_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_shader_image_desc {
    pub name: *const ::std::os::raw::c_char,
    pub image_type: sg_image_type,
    pub sampler_type: sg_sampler_type,
}
#[test]
fn bindgen_test_layout_sg_shader_image_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader_image_desc>(),
        16usize,
        concat!("Size of: ", stringify!(sg_shader_image_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader_image_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_shader_image_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_image_desc>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_image_desc),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_image_desc>())).image_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_image_desc),
            "::",
            stringify!(image_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_shader_image_desc>())).sampler_type as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_image_desc),
            "::",
            stringify!(sampler_type)
        )
    );
}
impl Default for sg_shader_image_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_shader_stage_desc {
    pub source: *const ::std::os::raw::c_char,
    pub bytecode: sg_range,
    pub entry: *const ::std::os::raw::c_char,
    pub d3d11_target: *const ::std::os::raw::c_char,
    pub uniform_blocks: [sg_shader_uniform_block_desc; 4usize],
    pub images: [sg_shader_image_desc; 12usize],
}
#[test]
fn bindgen_test_layout_sg_shader_stage_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader_stage_desc>(),
        1288usize,
        concat!("Size of: ", stringify!(sg_shader_stage_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader_stage_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_shader_stage_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_stage_desc>())).source as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_stage_desc),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_stage_desc>())).bytecode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_stage_desc),
            "::",
            stringify!(bytecode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_stage_desc>())).entry as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_stage_desc),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_shader_stage_desc>())).d3d11_target as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_stage_desc),
            "::",
            stringify!(d3d11_target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_shader_stage_desc>())).uniform_blocks as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_stage_desc),
            "::",
            stringify!(uniform_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_stage_desc>())).images as *const _ as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_stage_desc),
            "::",
            stringify!(images)
        )
    );
}
impl Default for sg_shader_stage_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_shader_desc {
    pub _start_canary: u32,
    pub attrs: [sg_shader_attr_desc; 16usize],
    pub vs: sg_shader_stage_desc,
    pub fs: sg_shader_stage_desc,
    pub label: *const ::std::os::raw::c_char,
    pub _end_canary: u32,
}
#[test]
fn bindgen_test_layout_sg_shader_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader_desc>(),
        2984usize,
        concat!("Size of: ", stringify!(sg_shader_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_shader_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_desc>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_desc),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_desc>())).attrs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_desc),
            "::",
            stringify!(attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_desc>())).vs as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_desc),
            "::",
            stringify!(vs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_desc>())).fs as *const _ as usize },
        1680usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_desc),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_desc>())).label as *const _ as usize },
        2968usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_desc),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_desc>()))._end_canary as *const _ as usize },
        2976usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_desc),
            "::",
            stringify!(_end_canary)
        )
    );
}
impl Default for sg_shader_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_buffer_layout_desc {
    pub stride: ::std::os::raw::c_int,
    pub step_func: sg_vertex_step,
    pub step_rate: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sg_buffer_layout_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_buffer_layout_desc>(),
        12usize,
        concat!("Size of: ", stringify!(sg_buffer_layout_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_buffer_layout_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_buffer_layout_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_layout_desc>())).stride as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_layout_desc),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_layout_desc>())).step_func as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_layout_desc),
            "::",
            stringify!(step_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_layout_desc>())).step_rate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_layout_desc),
            "::",
            stringify!(step_rate)
        )
    );
}
impl Default for sg_buffer_layout_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_vertex_attr_desc {
    pub buffer_index: ::std::os::raw::c_int,
    pub offset: ::std::os::raw::c_int,
    pub format: sg_vertex_format,
}
#[test]
fn bindgen_test_layout_sg_vertex_attr_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_vertex_attr_desc>(),
        12usize,
        concat!("Size of: ", stringify!(sg_vertex_attr_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_vertex_attr_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_vertex_attr_desc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_vertex_attr_desc>())).buffer_index as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_vertex_attr_desc),
            "::",
            stringify!(buffer_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_vertex_attr_desc>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_vertex_attr_desc),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_vertex_attr_desc>())).format as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_vertex_attr_desc),
            "::",
            stringify!(format)
        )
    );
}
impl Default for sg_vertex_attr_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_layout_desc {
    pub buffers: [sg_buffer_layout_desc; 8usize],
    pub attrs: [sg_vertex_attr_desc; 16usize],
}
#[test]
fn bindgen_test_layout_sg_layout_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_layout_desc>(),
        288usize,
        concat!("Size of: ", stringify!(sg_layout_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_layout_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_layout_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_layout_desc>())).buffers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_layout_desc),
            "::",
            stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_layout_desc>())).attrs as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_layout_desc),
            "::",
            stringify!(attrs)
        )
    );
}
impl Default for sg_layout_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_stencil_face_state {
    pub compare: sg_compare_func,
    pub fail_op: sg_stencil_op,
    pub depth_fail_op: sg_stencil_op,
    pub pass_op: sg_stencil_op,
}
#[test]
fn bindgen_test_layout_sg_stencil_face_state() {
    assert_eq!(
        ::std::mem::size_of::<sg_stencil_face_state>(),
        16usize,
        concat!("Size of: ", stringify!(sg_stencil_face_state))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_stencil_face_state>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_stencil_face_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_stencil_face_state>())).compare as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_face_state),
            "::",
            stringify!(compare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_stencil_face_state>())).fail_op as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_face_state),
            "::",
            stringify!(fail_op)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_stencil_face_state>())).depth_fail_op as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_face_state),
            "::",
            stringify!(depth_fail_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_stencil_face_state>())).pass_op as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_face_state),
            "::",
            stringify!(pass_op)
        )
    );
}
impl Default for sg_stencil_face_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_stencil_state {
    pub enabled: bool,
    pub front: sg_stencil_face_state,
    pub back: sg_stencil_face_state,
    pub read_mask: u8,
    pub write_mask: u8,
    pub ref_: u8,
}
#[test]
fn bindgen_test_layout_sg_stencil_state() {
    assert_eq!(
        ::std::mem::size_of::<sg_stencil_state>(),
        40usize,
        concat!("Size of: ", stringify!(sg_stencil_state))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_stencil_state>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_stencil_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_stencil_state>())).enabled as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_state),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_stencil_state>())).front as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_state),
            "::",
            stringify!(front)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_stencil_state>())).back as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_state),
            "::",
            stringify!(back)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_stencil_state>())).read_mask as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_state),
            "::",
            stringify!(read_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_stencil_state>())).write_mask as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_state),
            "::",
            stringify!(write_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_stencil_state>())).ref_ as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_state),
            "::",
            stringify!(ref_)
        )
    );
}
impl Default for sg_stencil_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct sg_depth_state {
    pub pixel_format: sg_pixel_format,
    pub compare: sg_compare_func,
    pub write_enabled: bool,
    pub bias: f32,
    pub bias_slope_scale: f32,
    pub bias_clamp: f32,
}
#[test]
fn bindgen_test_layout_sg_depth_state() {
    assert_eq!(
        ::std::mem::size_of::<sg_depth_state>(),
        24usize,
        concat!("Size of: ", stringify!(sg_depth_state))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_depth_state>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_depth_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_depth_state>())).pixel_format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_state),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_depth_state>())).compare as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_state),
            "::",
            stringify!(compare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_depth_state>())).write_enabled as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_state),
            "::",
            stringify!(write_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_depth_state>())).bias as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_state),
            "::",
            stringify!(bias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_depth_state>())).bias_slope_scale as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_state),
            "::",
            stringify!(bias_slope_scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_depth_state>())).bias_clamp as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_state),
            "::",
            stringify!(bias_clamp)
        )
    );
}
impl Default for sg_depth_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_blend_state {
    pub enabled: bool,
    pub src_factor_rgb: sg_blend_factor,
    pub dst_factor_rgb: sg_blend_factor,
    pub op_rgb: sg_blend_op,
    pub src_factor_alpha: sg_blend_factor,
    pub dst_factor_alpha: sg_blend_factor,
    pub op_alpha: sg_blend_op,
}
#[test]
fn bindgen_test_layout_sg_blend_state() {
    assert_eq!(
        ::std::mem::size_of::<sg_blend_state>(),
        28usize,
        concat!("Size of: ", stringify!(sg_blend_state))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_blend_state>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_blend_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).enabled as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).src_factor_rgb as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(src_factor_rgb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).dst_factor_rgb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(dst_factor_rgb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).op_rgb as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(op_rgb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).src_factor_alpha as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(src_factor_alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).dst_factor_alpha as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(dst_factor_alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).op_alpha as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(op_alpha)
        )
    );
}
impl Default for sg_blend_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_color_state {
    pub pixel_format: sg_pixel_format,
    pub write_mask: sg_color_mask,
    pub blend: sg_blend_state,
}
#[test]
fn bindgen_test_layout_sg_color_state() {
    assert_eq!(
        ::std::mem::size_of::<sg_color_state>(),
        36usize,
        concat!("Size of: ", stringify!(sg_color_state))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_color_state>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_color_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_color_state>())).pixel_format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_color_state),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_color_state>())).write_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_color_state),
            "::",
            stringify!(write_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_color_state>())).blend as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_color_state),
            "::",
            stringify!(blend)
        )
    );
}
impl Default for sg_color_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct sg_pipeline_desc {
    pub _start_canary: u32,
    pub shader: sg_shader,
    pub layout: sg_layout_desc,
    pub depth: sg_depth_state,
    pub stencil: sg_stencil_state,
    pub color_count: ::std::os::raw::c_int,
    pub colors: [sg_color_state; 4usize],
    pub primitive_type: sg_primitive_type,
    pub index_type: sg_index_type,
    pub cull_mode: sg_cull_mode,
    pub face_winding: sg_face_winding,
    pub sample_count: ::std::os::raw::c_int,
    pub blend_color: sg_color,
    pub alpha_to_coverage_enabled: bool,
    pub label: *const ::std::os::raw::c_char,
    pub _end_canary: u32,
}
#[test]
fn bindgen_test_layout_sg_pipeline_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_pipeline_desc>(),
        568usize,
        concat!("Size of: ", stringify!(sg_pipeline_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pipeline_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_pipeline_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).shader as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).layout as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).depth as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).stencil as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(stencil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).color_count as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(color_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).colors as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).primitive_type as *const _ as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(primitive_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).index_type as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(index_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).cull_mode as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(cull_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).face_winding as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(face_winding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).sample_count as *const _ as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(sample_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).blend_color as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(blend_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_pipeline_desc>())).alpha_to_coverage_enabled as *const _
                as usize
        },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(alpha_to_coverage_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).label as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>()))._end_canary as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(_end_canary)
        )
    );
}
impl Default for sg_pipeline_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sg_pass_attachment_desc {
    pub image: sg_image,
    pub mip_level: ::std::os::raw::c_int,
    pub slice: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sg_pass_attachment_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_pass_attachment_desc>(),
        12usize,
        concat!("Size of: ", stringify!(sg_pass_attachment_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pass_attachment_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_pass_attachment_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_attachment_desc>())).image as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_attachment_desc),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_pass_attachment_desc>())).mip_level as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_attachment_desc),
            "::",
            stringify!(mip_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_attachment_desc>())).slice as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_attachment_desc),
            "::",
            stringify!(slice)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_pass_desc {
    pub _start_canary: u32,
    pub color_attachments: [sg_pass_attachment_desc; 4usize],
    pub depth_stencil_attachment: sg_pass_attachment_desc,
    pub label: *const ::std::os::raw::c_char,
    pub _end_canary: u32,
}
#[test]
fn bindgen_test_layout_sg_pass_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_pass_desc>(),
        80usize,
        concat!("Size of: ", stringify!(sg_pass_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pass_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_pass_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_desc>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_desc),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_desc>())).color_attachments as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_desc),
            "::",
            stringify!(color_attachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_pass_desc>())).depth_stencil_attachment as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_desc),
            "::",
            stringify!(depth_stencil_attachment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_desc>())).label as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_desc),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_desc>()))._end_canary as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_desc),
            "::",
            stringify!(_end_canary)
        )
    );
}
impl Default for sg_pass_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_trace_hooks {
    pub user_data: *mut ::std::os::raw::c_void,
    pub reset_state_cache:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub make_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            desc: *const sg_buffer_desc,
            result: sg_buffer,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub make_image: ::std::option::Option<
        unsafe extern "C" fn(
            desc: *const sg_image_desc,
            result: sg_image,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub make_shader: ::std::option::Option<
        unsafe extern "C" fn(
            desc: *const sg_shader_desc,
            result: sg_shader,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub make_pipeline: ::std::option::Option<
        unsafe extern "C" fn(
            desc: *const sg_pipeline_desc,
            result: sg_pipeline,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub make_pass: ::std::option::Option<
        unsafe extern "C" fn(
            desc: *const sg_pass_desc,
            result: sg_pass,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub destroy_buffer: ::std::option::Option<
        unsafe extern "C" fn(buf: sg_buffer, user_data: *mut ::std::os::raw::c_void),
    >,
    pub destroy_image: ::std::option::Option<
        unsafe extern "C" fn(img: sg_image, user_data: *mut ::std::os::raw::c_void),
    >,
    pub destroy_shader: ::std::option::Option<
        unsafe extern "C" fn(shd: sg_shader, user_data: *mut ::std::os::raw::c_void),
    >,
    pub destroy_pipeline: ::std::option::Option<
        unsafe extern "C" fn(pip: sg_pipeline, user_data: *mut ::std::os::raw::c_void),
    >,
    pub destroy_pass: ::std::option::Option<
        unsafe extern "C" fn(pass: sg_pass, user_data: *mut ::std::os::raw::c_void),
    >,
    pub update_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            buf: sg_buffer,
            data: *const sg_range,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub update_image: ::std::option::Option<
        unsafe extern "C" fn(
            img: sg_image,
            data: *const sg_image_data,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub append_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            buf: sg_buffer,
            data: *const sg_range,
            result: ::std::os::raw::c_int,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub begin_default_pass: ::std::option::Option<
        unsafe extern "C" fn(
            pass_action: *const sg_pass_action,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub begin_pass: ::std::option::Option<
        unsafe extern "C" fn(
            pass: sg_pass,
            pass_action: *const sg_pass_action,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub apply_viewport: ::std::option::Option<
        unsafe extern "C" fn(
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            origin_top_left: bool,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub apply_scissor_rect: ::std::option::Option<
        unsafe extern "C" fn(
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            origin_top_left: bool,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub apply_pipeline: ::std::option::Option<
        unsafe extern "C" fn(pip: sg_pipeline, user_data: *mut ::std::os::raw::c_void),
    >,
    pub apply_bindings: ::std::option::Option<
        unsafe extern "C" fn(bindings: *const sg_bindings, user_data: *mut ::std::os::raw::c_void),
    >,
    pub apply_uniforms: ::std::option::Option<
        unsafe extern "C" fn(
            stage: sg_shader_stage,
            ub_index: ::std::os::raw::c_int,
            data: *const sg_range,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub draw: ::std::option::Option<
        unsafe extern "C" fn(
            base_element: ::std::os::raw::c_int,
            num_elements: ::std::os::raw::c_int,
            num_instances: ::std::os::raw::c_int,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub end_pass:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub commit: ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub alloc_buffer: ::std::option::Option<
        unsafe extern "C" fn(result: sg_buffer, user_data: *mut ::std::os::raw::c_void),
    >,
    pub alloc_image: ::std::option::Option<
        unsafe extern "C" fn(result: sg_image, user_data: *mut ::std::os::raw::c_void),
    >,
    pub alloc_shader: ::std::option::Option<
        unsafe extern "C" fn(result: sg_shader, user_data: *mut ::std::os::raw::c_void),
    >,
    pub alloc_pipeline: ::std::option::Option<
        unsafe extern "C" fn(result: sg_pipeline, user_data: *mut ::std::os::raw::c_void),
    >,
    pub alloc_pass: ::std::option::Option<
        unsafe extern "C" fn(result: sg_pass, user_data: *mut ::std::os::raw::c_void),
    >,
    pub dealloc_buffer: ::std::option::Option<
        unsafe extern "C" fn(buf_id: sg_buffer, user_data: *mut ::std::os::raw::c_void),
    >,
    pub dealloc_image: ::std::option::Option<
        unsafe extern "C" fn(img_id: sg_image, user_data: *mut ::std::os::raw::c_void),
    >,
    pub dealloc_shader: ::std::option::Option<
        unsafe extern "C" fn(shd_id: sg_shader, user_data: *mut ::std::os::raw::c_void),
    >,
    pub dealloc_pipeline: ::std::option::Option<
        unsafe extern "C" fn(pip_id: sg_pipeline, user_data: *mut ::std::os::raw::c_void),
    >,
    pub dealloc_pass: ::std::option::Option<
        unsafe extern "C" fn(pass_id: sg_pass, user_data: *mut ::std::os::raw::c_void),
    >,
    pub init_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            buf_id: sg_buffer,
            desc: *const sg_buffer_desc,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub init_image: ::std::option::Option<
        unsafe extern "C" fn(
            img_id: sg_image,
            desc: *const sg_image_desc,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub init_shader: ::std::option::Option<
        unsafe extern "C" fn(
            shd_id: sg_shader,
            desc: *const sg_shader_desc,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub init_pipeline: ::std::option::Option<
        unsafe extern "C" fn(
            pip_id: sg_pipeline,
            desc: *const sg_pipeline_desc,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub init_pass: ::std::option::Option<
        unsafe extern "C" fn(
            pass_id: sg_pass,
            desc: *const sg_pass_desc,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub uninit_buffer: ::std::option::Option<
        unsafe extern "C" fn(buf_id: sg_buffer, user_data: *mut ::std::os::raw::c_void),
    >,
    pub uninit_image: ::std::option::Option<
        unsafe extern "C" fn(img_id: sg_image, user_data: *mut ::std::os::raw::c_void),
    >,
    pub uninit_shader: ::std::option::Option<
        unsafe extern "C" fn(shd_id: sg_shader, user_data: *mut ::std::os::raw::c_void),
    >,
    pub uninit_pipeline: ::std::option::Option<
        unsafe extern "C" fn(pip_id: sg_pipeline, user_data: *mut ::std::os::raw::c_void),
    >,
    pub uninit_pass: ::std::option::Option<
        unsafe extern "C" fn(pass_id: sg_pass, user_data: *mut ::std::os::raw::c_void),
    >,
    pub fail_buffer: ::std::option::Option<
        unsafe extern "C" fn(buf_id: sg_buffer, user_data: *mut ::std::os::raw::c_void),
    >,
    pub fail_image: ::std::option::Option<
        unsafe extern "C" fn(img_id: sg_image, user_data: *mut ::std::os::raw::c_void),
    >,
    pub fail_shader: ::std::option::Option<
        unsafe extern "C" fn(shd_id: sg_shader, user_data: *mut ::std::os::raw::c_void),
    >,
    pub fail_pipeline: ::std::option::Option<
        unsafe extern "C" fn(pip_id: sg_pipeline, user_data: *mut ::std::os::raw::c_void),
    >,
    pub fail_pass: ::std::option::Option<
        unsafe extern "C" fn(pass_id: sg_pass, user_data: *mut ::std::os::raw::c_void),
    >,
    pub push_debug_group: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub pop_debug_group:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_buffer_pool_exhausted:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_image_pool_exhausted:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_shader_pool_exhausted:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_pipeline_pool_exhausted:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_pass_pool_exhausted:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_context_mismatch:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_pass_invalid:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_draw_invalid:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_bindings_invalid:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_sg_trace_hooks() {
    assert_eq!(
        ::std::mem::size_of::<sg_trace_hooks>(),
        488usize,
        concat!("Size of: ", stringify!(sg_trace_hooks))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_trace_hooks>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_trace_hooks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).user_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).reset_state_cache as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(reset_state_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).make_buffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(make_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).make_image as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(make_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).make_shader as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(make_shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).make_pipeline as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(make_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).make_pass as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(make_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).destroy_buffer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(destroy_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).destroy_image as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(destroy_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).destroy_shader as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(destroy_shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).destroy_pipeline as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(destroy_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).destroy_pass as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(destroy_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).update_buffer as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(update_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).update_image as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(update_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).append_buffer as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(append_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).begin_default_pass as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(begin_default_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).begin_pass as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(begin_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).apply_viewport as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(apply_viewport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).apply_scissor_rect as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(apply_scissor_rect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).apply_pipeline as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(apply_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).apply_bindings as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(apply_bindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).apply_uniforms as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(apply_uniforms)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).draw as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(draw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).end_pass as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(end_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).commit as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(commit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).alloc_buffer as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(alloc_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).alloc_image as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(alloc_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).alloc_shader as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(alloc_shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).alloc_pipeline as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(alloc_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).alloc_pass as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(alloc_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).dealloc_buffer as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(dealloc_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).dealloc_image as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(dealloc_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).dealloc_shader as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(dealloc_shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).dealloc_pipeline as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(dealloc_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).dealloc_pass as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(dealloc_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).init_buffer as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(init_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).init_image as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(init_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).init_shader as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(init_shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).init_pipeline as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(init_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).init_pass as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(init_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).uninit_buffer as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(uninit_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).uninit_image as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(uninit_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).uninit_shader as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(uninit_shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).uninit_pipeline as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(uninit_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).uninit_pass as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(uninit_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).fail_buffer as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(fail_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).fail_image as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(fail_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).fail_shader as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(fail_shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).fail_pipeline as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(fail_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).fail_pass as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(fail_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).push_debug_group as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(push_debug_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).pop_debug_group as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(pop_debug_group)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).err_buffer_pool_exhausted as *const _
                as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_buffer_pool_exhausted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).err_image_pool_exhausted as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_image_pool_exhausted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).err_shader_pool_exhausted as *const _
                as usize
        },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_shader_pool_exhausted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).err_pipeline_pool_exhausted as *const _
                as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_pipeline_pool_exhausted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).err_pass_pool_exhausted as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_pass_pool_exhausted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).err_context_mismatch as *const _ as usize
        },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_context_mismatch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).err_pass_invalid as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_pass_invalid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).err_draw_invalid as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_draw_invalid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).err_bindings_invalid as *const _ as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_bindings_invalid)
        )
    );
}
impl Default for sg_trace_hooks {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_slot_info {
    pub state: sg_resource_state,
    pub res_id: u32,
    pub ctx_id: u32,
}
#[test]
fn bindgen_test_layout_sg_slot_info() {
    assert_eq!(
        ::std::mem::size_of::<sg_slot_info>(),
        12usize,
        concat!("Size of: ", stringify!(sg_slot_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_slot_info>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_slot_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_slot_info>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_slot_info),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_slot_info>())).res_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_slot_info),
            "::",
            stringify!(res_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_slot_info>())).ctx_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_slot_info),
            "::",
            stringify!(ctx_id)
        )
    );
}
impl Default for sg_slot_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_buffer_info {
    pub slot: sg_slot_info,
    pub update_frame_index: u32,
    pub append_frame_index: u32,
    pub append_pos: ::std::os::raw::c_int,
    pub append_overflow: bool,
    pub num_slots: ::std::os::raw::c_int,
    pub active_slot: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sg_buffer_info() {
    assert_eq!(
        ::std::mem::size_of::<sg_buffer_info>(),
        36usize,
        concat!("Size of: ", stringify!(sg_buffer_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_buffer_info>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_buffer_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_info>())).slot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_info),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_buffer_info>())).update_frame_index as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_info),
            "::",
            stringify!(update_frame_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_buffer_info>())).append_frame_index as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_info),
            "::",
            stringify!(append_frame_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_info>())).append_pos as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_info),
            "::",
            stringify!(append_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_info>())).append_overflow as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_info),
            "::",
            stringify!(append_overflow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_info>())).num_slots as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_info),
            "::",
            stringify!(num_slots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_info>())).active_slot as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_info),
            "::",
            stringify!(active_slot)
        )
    );
}
impl Default for sg_buffer_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_image_info {
    pub slot: sg_slot_info,
    pub upd_frame_index: u32,
    pub num_slots: ::std::os::raw::c_int,
    pub active_slot: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sg_image_info() {
    assert_eq!(
        ::std::mem::size_of::<sg_image_info>(),
        32usize,
        concat!("Size of: ", stringify!(sg_image_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_image_info>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_image_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_info>())).slot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_info),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_info>())).upd_frame_index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_info),
            "::",
            stringify!(upd_frame_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_info>())).num_slots as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_info),
            "::",
            stringify!(num_slots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_info>())).active_slot as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_info),
            "::",
            stringify!(active_slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_info>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_info>())).height as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_info),
            "::",
            stringify!(height)
        )
    );
}
impl Default for sg_image_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_shader_info {
    pub slot: sg_slot_info,
}
#[test]
fn bindgen_test_layout_sg_shader_info() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader_info>(),
        12usize,
        concat!("Size of: ", stringify!(sg_shader_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader_info>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_shader_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_info>())).slot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_info),
            "::",
            stringify!(slot)
        )
    );
}
impl Default for sg_shader_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_pipeline_info {
    pub slot: sg_slot_info,
}
#[test]
fn bindgen_test_layout_sg_pipeline_info() {
    assert_eq!(
        ::std::mem::size_of::<sg_pipeline_info>(),
        12usize,
        concat!("Size of: ", stringify!(sg_pipeline_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pipeline_info>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_pipeline_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_info>())).slot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_info),
            "::",
            stringify!(slot)
        )
    );
}
impl Default for sg_pipeline_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_pass_info {
    pub slot: sg_slot_info,
}
#[test]
fn bindgen_test_layout_sg_pass_info() {
    assert_eq!(
        ::std::mem::size_of::<sg_pass_info>(),
        12usize,
        concat!("Size of: ", stringify!(sg_pass_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pass_info>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_pass_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_info>())).slot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_info),
            "::",
            stringify!(slot)
        )
    );
}
impl Default for sg_pass_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sg_gl_context_desc {
    pub force_gles2: bool,
}
#[test]
fn bindgen_test_layout_sg_gl_context_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_gl_context_desc>(),
        1usize,
        concat!("Size of: ", stringify!(sg_gl_context_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_gl_context_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(sg_gl_context_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_gl_context_desc>())).force_gles2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_gl_context_desc),
            "::",
            stringify!(force_gles2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_metal_context_desc {
    pub device: *const ::std::os::raw::c_void,
    pub renderpass_descriptor_cb:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_void>,
    pub renderpass_descriptor_userdata_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub drawable_cb: ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_void>,
    pub drawable_userdata_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sg_metal_context_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_metal_context_desc>(),
        48usize,
        concat!("Size of: ", stringify!(sg_metal_context_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_metal_context_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_metal_context_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_metal_context_desc>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_metal_context_desc),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_metal_context_desc>())).renderpass_descriptor_cb as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_metal_context_desc),
            "::",
            stringify!(renderpass_descriptor_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_metal_context_desc>())).renderpass_descriptor_userdata_cb
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_metal_context_desc),
            "::",
            stringify!(renderpass_descriptor_userdata_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_metal_context_desc>())).drawable_cb as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_metal_context_desc),
            "::",
            stringify!(drawable_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_metal_context_desc>())).drawable_userdata_cb as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_metal_context_desc),
            "::",
            stringify!(drawable_userdata_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_metal_context_desc>())).user_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_metal_context_desc),
            "::",
            stringify!(user_data)
        )
    );
}
impl Default for sg_metal_context_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_d3d11_context_desc {
    pub device: *const ::std::os::raw::c_void,
    pub device_context: *const ::std::os::raw::c_void,
    pub render_target_view_cb:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_void>,
    pub render_target_view_userdata_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub depth_stencil_view_cb:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_void>,
    pub depth_stencil_view_userdata_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sg_d3d11_context_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_d3d11_context_desc>(),
        56usize,
        concat!("Size of: ", stringify!(sg_d3d11_context_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_d3d11_context_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_d3d11_context_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_d3d11_context_desc>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_d3d11_context_desc),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_d3d11_context_desc>())).device_context as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_d3d11_context_desc),
            "::",
            stringify!(device_context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_d3d11_context_desc>())).render_target_view_cb as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_d3d11_context_desc),
            "::",
            stringify!(render_target_view_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_d3d11_context_desc>())).render_target_view_userdata_cb
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_d3d11_context_desc),
            "::",
            stringify!(render_target_view_userdata_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_d3d11_context_desc>())).depth_stencil_view_cb as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_d3d11_context_desc),
            "::",
            stringify!(depth_stencil_view_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_d3d11_context_desc>())).depth_stencil_view_userdata_cb
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_d3d11_context_desc),
            "::",
            stringify!(depth_stencil_view_userdata_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_d3d11_context_desc>())).user_data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_d3d11_context_desc),
            "::",
            stringify!(user_data)
        )
    );
}
impl Default for sg_d3d11_context_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_wgpu_context_desc {
    pub device: *const ::std::os::raw::c_void,
    pub render_view_cb:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_void>,
    pub render_view_userdata_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub resolve_view_cb:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_void>,
    pub resolve_view_userdata_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub depth_stencil_view_cb:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_void>,
    pub depth_stencil_view_userdata_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sg_wgpu_context_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_wgpu_context_desc>(),
        64usize,
        concat!("Size of: ", stringify!(sg_wgpu_context_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_wgpu_context_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_wgpu_context_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_wgpu_context_desc>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_wgpu_context_desc>())).render_view_cb as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(render_view_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_wgpu_context_desc>())).render_view_userdata_cb as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(render_view_userdata_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_wgpu_context_desc>())).resolve_view_cb as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(resolve_view_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_wgpu_context_desc>())).resolve_view_userdata_cb as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(resolve_view_userdata_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_wgpu_context_desc>())).depth_stencil_view_cb as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(depth_stencil_view_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_wgpu_context_desc>())).depth_stencil_view_userdata_cb
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(depth_stencil_view_userdata_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_wgpu_context_desc>())).user_data as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(user_data)
        )
    );
}
impl Default for sg_wgpu_context_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_context_desc {
    pub color_format: sg_pixel_format,
    pub depth_format: sg_pixel_format,
    pub sample_count: ::std::os::raw::c_int,
    pub gl: sg_gl_context_desc,
    pub metal: sg_metal_context_desc,
    pub d3d11: sg_d3d11_context_desc,
    pub wgpu: sg_wgpu_context_desc,
}
#[test]
fn bindgen_test_layout_sg_context_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_context_desc>(),
        184usize,
        concat!("Size of: ", stringify!(sg_context_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_context_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_context_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context_desc>())).color_format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context_desc),
            "::",
            stringify!(color_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context_desc>())).depth_format as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context_desc),
            "::",
            stringify!(depth_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context_desc>())).sample_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context_desc),
            "::",
            stringify!(sample_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context_desc>())).gl as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context_desc),
            "::",
            stringify!(gl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context_desc>())).metal as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context_desc),
            "::",
            stringify!(metal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context_desc>())).d3d11 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context_desc),
            "::",
            stringify!(d3d11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context_desc>())).wgpu as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context_desc),
            "::",
            stringify!(wgpu)
        )
    );
}
impl Default for sg_context_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sg_desc {
    pub _start_canary: u32,
    pub buffer_pool_size: ::std::os::raw::c_int,
    pub image_pool_size: ::std::os::raw::c_int,
    pub shader_pool_size: ::std::os::raw::c_int,
    pub pipeline_pool_size: ::std::os::raw::c_int,
    pub pass_pool_size: ::std::os::raw::c_int,
    pub context_pool_size: ::std::os::raw::c_int,
    pub uniform_buffer_size: ::std::os::raw::c_int,
    pub staging_buffer_size: ::std::os::raw::c_int,
    pub sampler_cache_size: ::std::os::raw::c_int,
    pub context: sg_context_desc,
    pub _end_canary: u32,
}
#[test]
fn bindgen_test_layout_sg_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_desc>(),
        232usize,
        concat!("Size of: ", stringify!(sg_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).buffer_pool_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(buffer_pool_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).image_pool_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(image_pool_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).shader_pool_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(shader_pool_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).pipeline_pool_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(pipeline_pool_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).pass_pool_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(pass_pool_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).context_pool_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(context_pool_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).uniform_buffer_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(uniform_buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).staging_buffer_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(staging_buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).sampler_cache_size as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(sampler_cache_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).context as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>()))._end_canary as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(_end_canary)
        )
    );
}
impl Default for sg_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn sg_setup(desc: *const sg_desc);
}
extern "C" {
    pub fn sg_shutdown();
}
extern "C" {
    pub fn sg_isvalid() -> bool;
}
extern "C" {
    pub fn sg_reset_state_cache();
}
extern "C" {
    pub fn sg_install_trace_hooks(trace_hooks: *const sg_trace_hooks) -> sg_trace_hooks;
}
extern "C" {
    pub fn sg_push_debug_group(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sg_pop_debug_group();
}
extern "C" {
    pub fn sg_make_buffer(desc: *const sg_buffer_desc) -> sg_buffer;
}
extern "C" {
    pub fn sg_make_image(desc: *const sg_image_desc) -> sg_image;
}
extern "C" {
    pub fn sg_make_shader(desc: *const sg_shader_desc) -> sg_shader;
}
extern "C" {
    pub fn sg_make_pipeline(desc: *const sg_pipeline_desc) -> sg_pipeline;
}
extern "C" {
    pub fn sg_make_pass(desc: *const sg_pass_desc) -> sg_pass;
}
extern "C" {
    pub fn sg_destroy_buffer(buf: sg_buffer);
}
extern "C" {
    pub fn sg_destroy_image(img: sg_image);
}
extern "C" {
    pub fn sg_destroy_shader(shd: sg_shader);
}
extern "C" {
    pub fn sg_destroy_pipeline(pip: sg_pipeline);
}
extern "C" {
    pub fn sg_destroy_pass(pass: sg_pass);
}
extern "C" {
    pub fn sg_update_buffer(buf: sg_buffer, data: *const sg_range);
}
extern "C" {
    pub fn sg_update_image(img: sg_image, data: *const sg_image_data);
}
extern "C" {
    pub fn sg_append_buffer(buf: sg_buffer, data: *const sg_range) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sg_query_buffer_overflow(buf: sg_buffer) -> bool;
}
extern "C" {
    pub fn sg_begin_default_pass(
        pass_action: *const sg_pass_action,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn sg_begin_default_passf(pass_action: *const sg_pass_action, width: f32, height: f32);
}
extern "C" {
    pub fn sg_begin_pass(pass: sg_pass, pass_action: *const sg_pass_action);
}
extern "C" {
    pub fn sg_apply_viewport(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        origin_top_left: bool,
    );
}
extern "C" {
    pub fn sg_apply_viewportf(x: f32, y: f32, width: f32, height: f32, origin_top_left: bool);
}
extern "C" {
    pub fn sg_apply_scissor_rect(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        origin_top_left: bool,
    );
}
extern "C" {
    pub fn sg_apply_scissor_rectf(x: f32, y: f32, width: f32, height: f32, origin_top_left: bool);
}
extern "C" {
    pub fn sg_apply_pipeline(pip: sg_pipeline);
}
extern "C" {
    pub fn sg_apply_bindings(bindings: *const sg_bindings);
}
extern "C" {
    pub fn sg_apply_uniforms(
        stage: sg_shader_stage,
        ub_index: ::std::os::raw::c_int,
        data: *const sg_range,
    );
}
extern "C" {
    pub fn sg_draw(
        base_element: ::std::os::raw::c_int,
        num_elements: ::std::os::raw::c_int,
        num_instances: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn sg_end_pass();
}
extern "C" {
    pub fn sg_commit();
}
extern "C" {
    pub fn sg_query_desc() -> sg_desc;
}
extern "C" {
    pub fn sg_query_backend() -> sg_backend;
}
extern "C" {
    pub fn sg_query_features() -> sg_features;
}
extern "C" {
    pub fn sg_query_limits() -> sg_limits;
}
extern "C" {
    pub fn sg_query_pixelformat(fmt: sg_pixel_format) -> sg_pixelformat_info;
}
extern "C" {
    pub fn sg_query_buffer_state(buf: sg_buffer) -> sg_resource_state;
}
extern "C" {
    pub fn sg_query_image_state(img: sg_image) -> sg_resource_state;
}
extern "C" {
    pub fn sg_query_shader_state(shd: sg_shader) -> sg_resource_state;
}
extern "C" {
    pub fn sg_query_pipeline_state(pip: sg_pipeline) -> sg_resource_state;
}
extern "C" {
    pub fn sg_query_pass_state(pass: sg_pass) -> sg_resource_state;
}
extern "C" {
    pub fn sg_query_buffer_info(buf: sg_buffer) -> sg_buffer_info;
}
extern "C" {
    pub fn sg_query_image_info(img: sg_image) -> sg_image_info;
}
extern "C" {
    pub fn sg_query_shader_info(shd: sg_shader) -> sg_shader_info;
}
extern "C" {
    pub fn sg_query_pipeline_info(pip: sg_pipeline) -> sg_pipeline_info;
}
extern "C" {
    pub fn sg_query_pass_info(pass: sg_pass) -> sg_pass_info;
}
extern "C" {
    pub fn sg_query_buffer_defaults(desc: *const sg_buffer_desc) -> sg_buffer_desc;
}
extern "C" {
    pub fn sg_query_image_defaults(desc: *const sg_image_desc) -> sg_image_desc;
}
extern "C" {
    pub fn sg_query_shader_defaults(desc: *const sg_shader_desc) -> sg_shader_desc;
}
extern "C" {
    pub fn sg_query_pipeline_defaults(desc: *const sg_pipeline_desc) -> sg_pipeline_desc;
}
extern "C" {
    pub fn sg_query_pass_defaults(desc: *const sg_pass_desc) -> sg_pass_desc;
}
extern "C" {
    pub fn sg_alloc_buffer() -> sg_buffer;
}
extern "C" {
    pub fn sg_alloc_image() -> sg_image;
}
extern "C" {
    pub fn sg_alloc_shader() -> sg_shader;
}
extern "C" {
    pub fn sg_alloc_pipeline() -> sg_pipeline;
}
extern "C" {
    pub fn sg_alloc_pass() -> sg_pass;
}
extern "C" {
    pub fn sg_dealloc_buffer(buf_id: sg_buffer);
}
extern "C" {
    pub fn sg_dealloc_image(img_id: sg_image);
}
extern "C" {
    pub fn sg_dealloc_shader(shd_id: sg_shader);
}
extern "C" {
    pub fn sg_dealloc_pipeline(pip_id: sg_pipeline);
}
extern "C" {
    pub fn sg_dealloc_pass(pass_id: sg_pass);
}
extern "C" {
    pub fn sg_init_buffer(buf_id: sg_buffer, desc: *const sg_buffer_desc);
}
extern "C" {
    pub fn sg_init_image(img_id: sg_image, desc: *const sg_image_desc);
}
extern "C" {
    pub fn sg_init_shader(shd_id: sg_shader, desc: *const sg_shader_desc);
}
extern "C" {
    pub fn sg_init_pipeline(pip_id: sg_pipeline, desc: *const sg_pipeline_desc);
}
extern "C" {
    pub fn sg_init_pass(pass_id: sg_pass, desc: *const sg_pass_desc);
}
extern "C" {
    pub fn sg_uninit_buffer(buf_id: sg_buffer) -> bool;
}
extern "C" {
    pub fn sg_uninit_image(img_id: sg_image) -> bool;
}
extern "C" {
    pub fn sg_uninit_shader(shd_id: sg_shader) -> bool;
}
extern "C" {
    pub fn sg_uninit_pipeline(pip_id: sg_pipeline) -> bool;
}
extern "C" {
    pub fn sg_uninit_pass(pass_id: sg_pass) -> bool;
}
extern "C" {
    pub fn sg_fail_buffer(buf_id: sg_buffer);
}
extern "C" {
    pub fn sg_fail_image(img_id: sg_image);
}
extern "C" {
    pub fn sg_fail_shader(shd_id: sg_shader);
}
extern "C" {
    pub fn sg_fail_pipeline(pip_id: sg_pipeline);
}
extern "C" {
    pub fn sg_fail_pass(pass_id: sg_pass);
}
extern "C" {
    pub fn sg_setup_context() -> sg_context;
}
extern "C" {
    pub fn sg_activate_context(ctx_id: sg_context);
}
extern "C" {
    pub fn sg_discard_context(ctx_id: sg_context);
}
extern "C" {
    pub fn sg_d3d11_device() -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sg_mtl_device() -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sg_mtl_render_command_encoder() -> *const ::std::os::raw::c_void;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}

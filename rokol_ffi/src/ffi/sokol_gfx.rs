/* automatically generated by rust-bindgen 0.55.1 */

pub const SOKOL_GFX_INCLUDED: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __darwin_pthread_handler_rec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_attr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_cond_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_mutex_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_rwlock_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sg_buffer {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_sg_buffer() {
    assert_eq!(
        ::std::mem::size_of::<sg_buffer>(),
        4usize,
        concat!("Size of: ", stringify!(sg_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_buffer>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sg_image {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_sg_image() {
    assert_eq!(
        ::std::mem::size_of::<sg_image>(),
        4usize,
        concat!("Size of: ", stringify!(sg_image))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_image>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_image))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sg_shader {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_sg_shader() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader>(),
        4usize,
        concat!("Size of: ", stringify!(sg_shader))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_shader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sg_pipeline {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_sg_pipeline() {
    assert_eq!(
        ::std::mem::size_of::<sg_pipeline>(),
        4usize,
        concat!("Size of: ", stringify!(sg_pipeline))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pipeline>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_pipeline))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sg_pass {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_sg_pass() {
    assert_eq!(
        ::std::mem::size_of::<sg_pass>(),
        4usize,
        concat!("Size of: ", stringify!(sg_pass))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pass>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_pass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sg_context {
    pub id: u32,
}
#[test]
fn bindgen_test_layout_sg_context() {
    assert_eq!(
        ::std::mem::size_of::<sg_context>(),
        4usize,
        concat!("Size of: ", stringify!(sg_context))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_context>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context),
            "::",
            stringify!(id)
        )
    );
}
pub const SG_INVALID_ID: ::std::os::raw::c_uint = 0;
pub const SG_NUM_SHADER_STAGES: ::std::os::raw::c_uint = 2;
pub const SG_NUM_INFLIGHT_FRAMES: ::std::os::raw::c_uint = 2;
pub const SG_MAX_COLOR_ATTACHMENTS: ::std::os::raw::c_uint = 4;
pub const SG_MAX_SHADERSTAGE_BUFFERS: ::std::os::raw::c_uint = 8;
pub const SG_MAX_SHADERSTAGE_IMAGES: ::std::os::raw::c_uint = 12;
pub const SG_MAX_SHADERSTAGE_UBS: ::std::os::raw::c_uint = 4;
pub const SG_MAX_UB_MEMBERS: ::std::os::raw::c_uint = 16;
pub const SG_MAX_VERTEX_ATTRIBUTES: ::std::os::raw::c_uint = 16;
pub const SG_MAX_MIPMAPS: ::std::os::raw::c_uint = 16;
pub const SG_MAX_TEXTUREARRAY_LAYERS: ::std::os::raw::c_uint = 128;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const sg_backend_SG_BACKEND_GLCORE33: sg_backend = 0;
pub const sg_backend_SG_BACKEND_GLES2: sg_backend = 1;
pub const sg_backend_SG_BACKEND_GLES3: sg_backend = 2;
pub const sg_backend_SG_BACKEND_D3D11: sg_backend = 3;
pub const sg_backend_SG_BACKEND_METAL_IOS: sg_backend = 4;
pub const sg_backend_SG_BACKEND_METAL_MACOS: sg_backend = 5;
pub const sg_backend_SG_BACKEND_METAL_SIMULATOR: sg_backend = 6;
pub const sg_backend_SG_BACKEND_WGPU: sg_backend = 7;
pub const sg_backend_SG_BACKEND_DUMMY: sg_backend = 8;
pub type sg_backend = ::std::os::raw::c_uint;
pub const sg_pixel_format__SG_PIXELFORMAT_DEFAULT: sg_pixel_format = 0;
pub const sg_pixel_format_SG_PIXELFORMAT_NONE: sg_pixel_format = 1;
pub const sg_pixel_format_SG_PIXELFORMAT_R8: sg_pixel_format = 2;
pub const sg_pixel_format_SG_PIXELFORMAT_R8SN: sg_pixel_format = 3;
pub const sg_pixel_format_SG_PIXELFORMAT_R8UI: sg_pixel_format = 4;
pub const sg_pixel_format_SG_PIXELFORMAT_R8SI: sg_pixel_format = 5;
pub const sg_pixel_format_SG_PIXELFORMAT_R16: sg_pixel_format = 6;
pub const sg_pixel_format_SG_PIXELFORMAT_R16SN: sg_pixel_format = 7;
pub const sg_pixel_format_SG_PIXELFORMAT_R16UI: sg_pixel_format = 8;
pub const sg_pixel_format_SG_PIXELFORMAT_R16SI: sg_pixel_format = 9;
pub const sg_pixel_format_SG_PIXELFORMAT_R16F: sg_pixel_format = 10;
pub const sg_pixel_format_SG_PIXELFORMAT_RG8: sg_pixel_format = 11;
pub const sg_pixel_format_SG_PIXELFORMAT_RG8SN: sg_pixel_format = 12;
pub const sg_pixel_format_SG_PIXELFORMAT_RG8UI: sg_pixel_format = 13;
pub const sg_pixel_format_SG_PIXELFORMAT_RG8SI: sg_pixel_format = 14;
pub const sg_pixel_format_SG_PIXELFORMAT_R32UI: sg_pixel_format = 15;
pub const sg_pixel_format_SG_PIXELFORMAT_R32SI: sg_pixel_format = 16;
pub const sg_pixel_format_SG_PIXELFORMAT_R32F: sg_pixel_format = 17;
pub const sg_pixel_format_SG_PIXELFORMAT_RG16: sg_pixel_format = 18;
pub const sg_pixel_format_SG_PIXELFORMAT_RG16SN: sg_pixel_format = 19;
pub const sg_pixel_format_SG_PIXELFORMAT_RG16UI: sg_pixel_format = 20;
pub const sg_pixel_format_SG_PIXELFORMAT_RG16SI: sg_pixel_format = 21;
pub const sg_pixel_format_SG_PIXELFORMAT_RG16F: sg_pixel_format = 22;
pub const sg_pixel_format_SG_PIXELFORMAT_RGBA8: sg_pixel_format = 23;
pub const sg_pixel_format_SG_PIXELFORMAT_RGBA8SN: sg_pixel_format = 24;
pub const sg_pixel_format_SG_PIXELFORMAT_RGBA8UI: sg_pixel_format = 25;
pub const sg_pixel_format_SG_PIXELFORMAT_RGBA8SI: sg_pixel_format = 26;
pub const sg_pixel_format_SG_PIXELFORMAT_BGRA8: sg_pixel_format = 27;
pub const sg_pixel_format_SG_PIXELFORMAT_RGB10A2: sg_pixel_format = 28;
pub const sg_pixel_format_SG_PIXELFORMAT_RG11B10F: sg_pixel_format = 29;
pub const sg_pixel_format_SG_PIXELFORMAT_RG32UI: sg_pixel_format = 30;
pub const sg_pixel_format_SG_PIXELFORMAT_RG32SI: sg_pixel_format = 31;
pub const sg_pixel_format_SG_PIXELFORMAT_RG32F: sg_pixel_format = 32;
pub const sg_pixel_format_SG_PIXELFORMAT_RGBA16: sg_pixel_format = 33;
pub const sg_pixel_format_SG_PIXELFORMAT_RGBA16SN: sg_pixel_format = 34;
pub const sg_pixel_format_SG_PIXELFORMAT_RGBA16UI: sg_pixel_format = 35;
pub const sg_pixel_format_SG_PIXELFORMAT_RGBA16SI: sg_pixel_format = 36;
pub const sg_pixel_format_SG_PIXELFORMAT_RGBA16F: sg_pixel_format = 37;
pub const sg_pixel_format_SG_PIXELFORMAT_RGBA32UI: sg_pixel_format = 38;
pub const sg_pixel_format_SG_PIXELFORMAT_RGBA32SI: sg_pixel_format = 39;
pub const sg_pixel_format_SG_PIXELFORMAT_RGBA32F: sg_pixel_format = 40;
pub const sg_pixel_format_SG_PIXELFORMAT_DEPTH: sg_pixel_format = 41;
pub const sg_pixel_format_SG_PIXELFORMAT_DEPTH_STENCIL: sg_pixel_format = 42;
pub const sg_pixel_format_SG_PIXELFORMAT_BC1_RGBA: sg_pixel_format = 43;
pub const sg_pixel_format_SG_PIXELFORMAT_BC2_RGBA: sg_pixel_format = 44;
pub const sg_pixel_format_SG_PIXELFORMAT_BC3_RGBA: sg_pixel_format = 45;
pub const sg_pixel_format_SG_PIXELFORMAT_BC4_R: sg_pixel_format = 46;
pub const sg_pixel_format_SG_PIXELFORMAT_BC4_RSN: sg_pixel_format = 47;
pub const sg_pixel_format_SG_PIXELFORMAT_BC5_RG: sg_pixel_format = 48;
pub const sg_pixel_format_SG_PIXELFORMAT_BC5_RGSN: sg_pixel_format = 49;
pub const sg_pixel_format_SG_PIXELFORMAT_BC6H_RGBF: sg_pixel_format = 50;
pub const sg_pixel_format_SG_PIXELFORMAT_BC6H_RGBUF: sg_pixel_format = 51;
pub const sg_pixel_format_SG_PIXELFORMAT_BC7_RGBA: sg_pixel_format = 52;
pub const sg_pixel_format_SG_PIXELFORMAT_PVRTC_RGB_2BPP: sg_pixel_format = 53;
pub const sg_pixel_format_SG_PIXELFORMAT_PVRTC_RGB_4BPP: sg_pixel_format = 54;
pub const sg_pixel_format_SG_PIXELFORMAT_PVRTC_RGBA_2BPP: sg_pixel_format = 55;
pub const sg_pixel_format_SG_PIXELFORMAT_PVRTC_RGBA_4BPP: sg_pixel_format = 56;
pub const sg_pixel_format_SG_PIXELFORMAT_ETC2_RGB8: sg_pixel_format = 57;
pub const sg_pixel_format_SG_PIXELFORMAT_ETC2_RGB8A1: sg_pixel_format = 58;
pub const sg_pixel_format_SG_PIXELFORMAT_ETC2_RGBA8: sg_pixel_format = 59;
pub const sg_pixel_format_SG_PIXELFORMAT_ETC2_RG11: sg_pixel_format = 60;
pub const sg_pixel_format_SG_PIXELFORMAT_ETC2_RG11SN: sg_pixel_format = 61;
pub const sg_pixel_format__SG_PIXELFORMAT_NUM: sg_pixel_format = 62;
pub const sg_pixel_format__SG_PIXELFORMAT_FORCE_U32: sg_pixel_format = 2147483647;
pub type sg_pixel_format = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sg_pixelformat_info {
    pub sample: bool,
    pub filter: bool,
    pub render: bool,
    pub blend: bool,
    pub msaa: bool,
    pub depth: bool,
}
#[test]
fn bindgen_test_layout_sg_pixelformat_info() {
    assert_eq!(
        ::std::mem::size_of::<sg_pixelformat_info>(),
        6usize,
        concat!("Size of: ", stringify!(sg_pixelformat_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pixelformat_info>(),
        1usize,
        concat!("Alignment of ", stringify!(sg_pixelformat_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pixelformat_info>())).sample as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pixelformat_info),
            "::",
            stringify!(sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pixelformat_info>())).filter as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pixelformat_info),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pixelformat_info>())).render as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pixelformat_info),
            "::",
            stringify!(render)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pixelformat_info>())).blend as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pixelformat_info),
            "::",
            stringify!(blend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pixelformat_info>())).msaa as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pixelformat_info),
            "::",
            stringify!(msaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pixelformat_info>())).depth as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pixelformat_info),
            "::",
            stringify!(depth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sg_features {
    pub instancing: bool,
    pub origin_top_left: bool,
    pub multiple_render_targets: bool,
    pub msaa_render_targets: bool,
    pub imagetype_3d: bool,
    pub imagetype_array: bool,
    pub image_clamp_to_border: bool,
}
#[test]
fn bindgen_test_layout_sg_features() {
    assert_eq!(
        ::std::mem::size_of::<sg_features>(),
        7usize,
        concat!("Size of: ", stringify!(sg_features))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_features>(),
        1usize,
        concat!("Alignment of ", stringify!(sg_features))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_features>())).instancing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(instancing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_features>())).origin_top_left as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(origin_top_left)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_features>())).multiple_render_targets as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(multiple_render_targets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_features>())).msaa_render_targets as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(msaa_render_targets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_features>())).imagetype_3d as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(imagetype_3d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_features>())).imagetype_array as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(imagetype_array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_features>())).image_clamp_to_border as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_features),
            "::",
            stringify!(image_clamp_to_border)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sg_limits {
    pub max_image_size_2d: u32,
    pub max_image_size_cube: u32,
    pub max_image_size_3d: u32,
    pub max_image_size_array: u32,
    pub max_image_array_layers: u32,
    pub max_vertex_attrs: u32,
}
#[test]
fn bindgen_test_layout_sg_limits() {
    assert_eq!(
        ::std::mem::size_of::<sg_limits>(),
        24usize,
        concat!("Size of: ", stringify!(sg_limits))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_limits>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_limits))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_limits>())).max_image_size_2d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_limits),
            "::",
            stringify!(max_image_size_2d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_limits>())).max_image_size_cube as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_limits),
            "::",
            stringify!(max_image_size_cube)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_limits>())).max_image_size_3d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_limits),
            "::",
            stringify!(max_image_size_3d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_limits>())).max_image_size_array as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_limits),
            "::",
            stringify!(max_image_size_array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_limits>())).max_image_array_layers as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_limits),
            "::",
            stringify!(max_image_array_layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_limits>())).max_vertex_attrs as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_limits),
            "::",
            stringify!(max_vertex_attrs)
        )
    );
}
pub const sg_resource_state_SG_RESOURCESTATE_INITIAL: sg_resource_state = 0;
pub const sg_resource_state_SG_RESOURCESTATE_ALLOC: sg_resource_state = 1;
pub const sg_resource_state_SG_RESOURCESTATE_VALID: sg_resource_state = 2;
pub const sg_resource_state_SG_RESOURCESTATE_FAILED: sg_resource_state = 3;
pub const sg_resource_state_SG_RESOURCESTATE_INVALID: sg_resource_state = 4;
pub const sg_resource_state__SG_RESOURCESTATE_FORCE_U32: sg_resource_state = 2147483647;
pub type sg_resource_state = ::std::os::raw::c_uint;
pub const sg_usage__SG_USAGE_DEFAULT: sg_usage = 0;
pub const sg_usage_SG_USAGE_IMMUTABLE: sg_usage = 1;
pub const sg_usage_SG_USAGE_DYNAMIC: sg_usage = 2;
pub const sg_usage_SG_USAGE_STREAM: sg_usage = 3;
pub const sg_usage__SG_USAGE_NUM: sg_usage = 4;
pub const sg_usage__SG_USAGE_FORCE_U32: sg_usage = 2147483647;
pub type sg_usage = ::std::os::raw::c_uint;
pub const sg_buffer_type__SG_BUFFERTYPE_DEFAULT: sg_buffer_type = 0;
pub const sg_buffer_type_SG_BUFFERTYPE_VERTEXBUFFER: sg_buffer_type = 1;
pub const sg_buffer_type_SG_BUFFERTYPE_INDEXBUFFER: sg_buffer_type = 2;
pub const sg_buffer_type__SG_BUFFERTYPE_NUM: sg_buffer_type = 3;
pub const sg_buffer_type__SG_BUFFERTYPE_FORCE_U32: sg_buffer_type = 2147483647;
pub type sg_buffer_type = ::std::os::raw::c_uint;
pub const sg_index_type__SG_INDEXTYPE_DEFAULT: sg_index_type = 0;
pub const sg_index_type_SG_INDEXTYPE_NONE: sg_index_type = 1;
pub const sg_index_type_SG_INDEXTYPE_UINT16: sg_index_type = 2;
pub const sg_index_type_SG_INDEXTYPE_UINT32: sg_index_type = 3;
pub const sg_index_type__SG_INDEXTYPE_NUM: sg_index_type = 4;
pub const sg_index_type__SG_INDEXTYPE_FORCE_U32: sg_index_type = 2147483647;
pub type sg_index_type = ::std::os::raw::c_uint;
pub const sg_image_type__SG_IMAGETYPE_DEFAULT: sg_image_type = 0;
pub const sg_image_type_SG_IMAGETYPE_2D: sg_image_type = 1;
pub const sg_image_type_SG_IMAGETYPE_CUBE: sg_image_type = 2;
pub const sg_image_type_SG_IMAGETYPE_3D: sg_image_type = 3;
pub const sg_image_type_SG_IMAGETYPE_ARRAY: sg_image_type = 4;
pub const sg_image_type__SG_IMAGETYPE_NUM: sg_image_type = 5;
pub const sg_image_type__SG_IMAGETYPE_FORCE_U32: sg_image_type = 2147483647;
pub type sg_image_type = ::std::os::raw::c_uint;
pub const sg_sampler_type__SG_SAMPLERTYPE_DEFAULT: sg_sampler_type = 0;
pub const sg_sampler_type_SG_SAMPLERTYPE_FLOAT: sg_sampler_type = 1;
pub const sg_sampler_type_SG_SAMPLERTYPE_SINT: sg_sampler_type = 2;
pub const sg_sampler_type_SG_SAMPLERTYPE_UINT: sg_sampler_type = 3;
pub type sg_sampler_type = ::std::os::raw::c_uint;
pub const sg_cube_face_SG_CUBEFACE_POS_X: sg_cube_face = 0;
pub const sg_cube_face_SG_CUBEFACE_NEG_X: sg_cube_face = 1;
pub const sg_cube_face_SG_CUBEFACE_POS_Y: sg_cube_face = 2;
pub const sg_cube_face_SG_CUBEFACE_NEG_Y: sg_cube_face = 3;
pub const sg_cube_face_SG_CUBEFACE_POS_Z: sg_cube_face = 4;
pub const sg_cube_face_SG_CUBEFACE_NEG_Z: sg_cube_face = 5;
pub const sg_cube_face_SG_CUBEFACE_NUM: sg_cube_face = 6;
pub const sg_cube_face__SG_CUBEFACE_FORCE_U32: sg_cube_face = 2147483647;
pub type sg_cube_face = ::std::os::raw::c_uint;
pub const sg_shader_stage_SG_SHADERSTAGE_VS: sg_shader_stage = 0;
pub const sg_shader_stage_SG_SHADERSTAGE_FS: sg_shader_stage = 1;
pub const sg_shader_stage__SG_SHADERSTAGE_FORCE_U32: sg_shader_stage = 2147483647;
pub type sg_shader_stage = ::std::os::raw::c_uint;
pub const sg_primitive_type__SG_PRIMITIVETYPE_DEFAULT: sg_primitive_type = 0;
pub const sg_primitive_type_SG_PRIMITIVETYPE_POINTS: sg_primitive_type = 1;
pub const sg_primitive_type_SG_PRIMITIVETYPE_LINES: sg_primitive_type = 2;
pub const sg_primitive_type_SG_PRIMITIVETYPE_LINE_STRIP: sg_primitive_type = 3;
pub const sg_primitive_type_SG_PRIMITIVETYPE_TRIANGLES: sg_primitive_type = 4;
pub const sg_primitive_type_SG_PRIMITIVETYPE_TRIANGLE_STRIP: sg_primitive_type = 5;
pub const sg_primitive_type__SG_PRIMITIVETYPE_NUM: sg_primitive_type = 6;
pub const sg_primitive_type__SG_PRIMITIVETYPE_FORCE_U32: sg_primitive_type = 2147483647;
pub type sg_primitive_type = ::std::os::raw::c_uint;
pub const sg_filter__SG_FILTER_DEFAULT: sg_filter = 0;
pub const sg_filter_SG_FILTER_NEAREST: sg_filter = 1;
pub const sg_filter_SG_FILTER_LINEAR: sg_filter = 2;
pub const sg_filter_SG_FILTER_NEAREST_MIPMAP_NEAREST: sg_filter = 3;
pub const sg_filter_SG_FILTER_NEAREST_MIPMAP_LINEAR: sg_filter = 4;
pub const sg_filter_SG_FILTER_LINEAR_MIPMAP_NEAREST: sg_filter = 5;
pub const sg_filter_SG_FILTER_LINEAR_MIPMAP_LINEAR: sg_filter = 6;
pub const sg_filter__SG_FILTER_NUM: sg_filter = 7;
pub const sg_filter__SG_FILTER_FORCE_U32: sg_filter = 2147483647;
pub type sg_filter = ::std::os::raw::c_uint;
pub const sg_wrap__SG_WRAP_DEFAULT: sg_wrap = 0;
pub const sg_wrap_SG_WRAP_REPEAT: sg_wrap = 1;
pub const sg_wrap_SG_WRAP_CLAMP_TO_EDGE: sg_wrap = 2;
pub const sg_wrap_SG_WRAP_CLAMP_TO_BORDER: sg_wrap = 3;
pub const sg_wrap_SG_WRAP_MIRRORED_REPEAT: sg_wrap = 4;
pub const sg_wrap__SG_WRAP_NUM: sg_wrap = 5;
pub const sg_wrap__SG_WRAP_FORCE_U32: sg_wrap = 2147483647;
pub type sg_wrap = ::std::os::raw::c_uint;
pub const sg_border_color__SG_BORDERCOLOR_DEFAULT: sg_border_color = 0;
pub const sg_border_color_SG_BORDERCOLOR_TRANSPARENT_BLACK: sg_border_color = 1;
pub const sg_border_color_SG_BORDERCOLOR_OPAQUE_BLACK: sg_border_color = 2;
pub const sg_border_color_SG_BORDERCOLOR_OPAQUE_WHITE: sg_border_color = 3;
pub const sg_border_color__SG_BORDERCOLOR_NUM: sg_border_color = 4;
pub const sg_border_color__SG_BORDERCOLOR_FORCE_U32: sg_border_color = 2147483647;
pub type sg_border_color = ::std::os::raw::c_uint;
pub const sg_vertex_format_SG_VERTEXFORMAT_INVALID: sg_vertex_format = 0;
pub const sg_vertex_format_SG_VERTEXFORMAT_FLOAT: sg_vertex_format = 1;
pub const sg_vertex_format_SG_VERTEXFORMAT_FLOAT2: sg_vertex_format = 2;
pub const sg_vertex_format_SG_VERTEXFORMAT_FLOAT3: sg_vertex_format = 3;
pub const sg_vertex_format_SG_VERTEXFORMAT_FLOAT4: sg_vertex_format = 4;
pub const sg_vertex_format_SG_VERTEXFORMAT_BYTE4: sg_vertex_format = 5;
pub const sg_vertex_format_SG_VERTEXFORMAT_BYTE4N: sg_vertex_format = 6;
pub const sg_vertex_format_SG_VERTEXFORMAT_UBYTE4: sg_vertex_format = 7;
pub const sg_vertex_format_SG_VERTEXFORMAT_UBYTE4N: sg_vertex_format = 8;
pub const sg_vertex_format_SG_VERTEXFORMAT_SHORT2: sg_vertex_format = 9;
pub const sg_vertex_format_SG_VERTEXFORMAT_SHORT2N: sg_vertex_format = 10;
pub const sg_vertex_format_SG_VERTEXFORMAT_USHORT2N: sg_vertex_format = 11;
pub const sg_vertex_format_SG_VERTEXFORMAT_SHORT4: sg_vertex_format = 12;
pub const sg_vertex_format_SG_VERTEXFORMAT_SHORT4N: sg_vertex_format = 13;
pub const sg_vertex_format_SG_VERTEXFORMAT_USHORT4N: sg_vertex_format = 14;
pub const sg_vertex_format_SG_VERTEXFORMAT_UINT10_N2: sg_vertex_format = 15;
pub const sg_vertex_format__SG_VERTEXFORMAT_NUM: sg_vertex_format = 16;
pub const sg_vertex_format__SG_VERTEXFORMAT_FORCE_U32: sg_vertex_format = 2147483647;
pub type sg_vertex_format = ::std::os::raw::c_uint;
pub const sg_vertex_step__SG_VERTEXSTEP_DEFAULT: sg_vertex_step = 0;
pub const sg_vertex_step_SG_VERTEXSTEP_PER_VERTEX: sg_vertex_step = 1;
pub const sg_vertex_step_SG_VERTEXSTEP_PER_INSTANCE: sg_vertex_step = 2;
pub const sg_vertex_step__SG_VERTEXSTEP_NUM: sg_vertex_step = 3;
pub const sg_vertex_step__SG_VERTEXSTEP_FORCE_U32: sg_vertex_step = 2147483647;
pub type sg_vertex_step = ::std::os::raw::c_uint;
pub const sg_uniform_type_SG_UNIFORMTYPE_INVALID: sg_uniform_type = 0;
pub const sg_uniform_type_SG_UNIFORMTYPE_FLOAT: sg_uniform_type = 1;
pub const sg_uniform_type_SG_UNIFORMTYPE_FLOAT2: sg_uniform_type = 2;
pub const sg_uniform_type_SG_UNIFORMTYPE_FLOAT3: sg_uniform_type = 3;
pub const sg_uniform_type_SG_UNIFORMTYPE_FLOAT4: sg_uniform_type = 4;
pub const sg_uniform_type_SG_UNIFORMTYPE_MAT4: sg_uniform_type = 5;
pub const sg_uniform_type__SG_UNIFORMTYPE_NUM: sg_uniform_type = 6;
pub const sg_uniform_type__SG_UNIFORMTYPE_FORCE_U32: sg_uniform_type = 2147483647;
pub type sg_uniform_type = ::std::os::raw::c_uint;
pub const sg_cull_mode__SG_CULLMODE_DEFAULT: sg_cull_mode = 0;
pub const sg_cull_mode_SG_CULLMODE_NONE: sg_cull_mode = 1;
pub const sg_cull_mode_SG_CULLMODE_FRONT: sg_cull_mode = 2;
pub const sg_cull_mode_SG_CULLMODE_BACK: sg_cull_mode = 3;
pub const sg_cull_mode__SG_CULLMODE_NUM: sg_cull_mode = 4;
pub const sg_cull_mode__SG_CULLMODE_FORCE_U32: sg_cull_mode = 2147483647;
pub type sg_cull_mode = ::std::os::raw::c_uint;
pub const sg_face_winding__SG_FACEWINDING_DEFAULT: sg_face_winding = 0;
pub const sg_face_winding_SG_FACEWINDING_CCW: sg_face_winding = 1;
pub const sg_face_winding_SG_FACEWINDING_CW: sg_face_winding = 2;
pub const sg_face_winding__SG_FACEWINDING_NUM: sg_face_winding = 3;
pub const sg_face_winding__SG_FACEWINDING_FORCE_U32: sg_face_winding = 2147483647;
pub type sg_face_winding = ::std::os::raw::c_uint;
pub const sg_compare_func__SG_COMPAREFUNC_DEFAULT: sg_compare_func = 0;
pub const sg_compare_func_SG_COMPAREFUNC_NEVER: sg_compare_func = 1;
pub const sg_compare_func_SG_COMPAREFUNC_LESS: sg_compare_func = 2;
pub const sg_compare_func_SG_COMPAREFUNC_EQUAL: sg_compare_func = 3;
pub const sg_compare_func_SG_COMPAREFUNC_LESS_EQUAL: sg_compare_func = 4;
pub const sg_compare_func_SG_COMPAREFUNC_GREATER: sg_compare_func = 5;
pub const sg_compare_func_SG_COMPAREFUNC_NOT_EQUAL: sg_compare_func = 6;
pub const sg_compare_func_SG_COMPAREFUNC_GREATER_EQUAL: sg_compare_func = 7;
pub const sg_compare_func_SG_COMPAREFUNC_ALWAYS: sg_compare_func = 8;
pub const sg_compare_func__SG_COMPAREFUNC_NUM: sg_compare_func = 9;
pub const sg_compare_func__SG_COMPAREFUNC_FORCE_U32: sg_compare_func = 2147483647;
pub type sg_compare_func = ::std::os::raw::c_uint;
pub const sg_stencil_op__SG_STENCILOP_DEFAULT: sg_stencil_op = 0;
pub const sg_stencil_op_SG_STENCILOP_KEEP: sg_stencil_op = 1;
pub const sg_stencil_op_SG_STENCILOP_ZERO: sg_stencil_op = 2;
pub const sg_stencil_op_SG_STENCILOP_REPLACE: sg_stencil_op = 3;
pub const sg_stencil_op_SG_STENCILOP_INCR_CLAMP: sg_stencil_op = 4;
pub const sg_stencil_op_SG_STENCILOP_DECR_CLAMP: sg_stencil_op = 5;
pub const sg_stencil_op_SG_STENCILOP_INVERT: sg_stencil_op = 6;
pub const sg_stencil_op_SG_STENCILOP_INCR_WRAP: sg_stencil_op = 7;
pub const sg_stencil_op_SG_STENCILOP_DECR_WRAP: sg_stencil_op = 8;
pub const sg_stencil_op__SG_STENCILOP_NUM: sg_stencil_op = 9;
pub const sg_stencil_op__SG_STENCILOP_FORCE_U32: sg_stencil_op = 2147483647;
pub type sg_stencil_op = ::std::os::raw::c_uint;
pub const sg_blend_factor__SG_BLENDFACTOR_DEFAULT: sg_blend_factor = 0;
pub const sg_blend_factor_SG_BLENDFACTOR_ZERO: sg_blend_factor = 1;
pub const sg_blend_factor_SG_BLENDFACTOR_ONE: sg_blend_factor = 2;
pub const sg_blend_factor_SG_BLENDFACTOR_SRC_COLOR: sg_blend_factor = 3;
pub const sg_blend_factor_SG_BLENDFACTOR_ONE_MINUS_SRC_COLOR: sg_blend_factor = 4;
pub const sg_blend_factor_SG_BLENDFACTOR_SRC_ALPHA: sg_blend_factor = 5;
pub const sg_blend_factor_SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA: sg_blend_factor = 6;
pub const sg_blend_factor_SG_BLENDFACTOR_DST_COLOR: sg_blend_factor = 7;
pub const sg_blend_factor_SG_BLENDFACTOR_ONE_MINUS_DST_COLOR: sg_blend_factor = 8;
pub const sg_blend_factor_SG_BLENDFACTOR_DST_ALPHA: sg_blend_factor = 9;
pub const sg_blend_factor_SG_BLENDFACTOR_ONE_MINUS_DST_ALPHA: sg_blend_factor = 10;
pub const sg_blend_factor_SG_BLENDFACTOR_SRC_ALPHA_SATURATED: sg_blend_factor = 11;
pub const sg_blend_factor_SG_BLENDFACTOR_BLEND_COLOR: sg_blend_factor = 12;
pub const sg_blend_factor_SG_BLENDFACTOR_ONE_MINUS_BLEND_COLOR: sg_blend_factor = 13;
pub const sg_blend_factor_SG_BLENDFACTOR_BLEND_ALPHA: sg_blend_factor = 14;
pub const sg_blend_factor_SG_BLENDFACTOR_ONE_MINUS_BLEND_ALPHA: sg_blend_factor = 15;
pub const sg_blend_factor__SG_BLENDFACTOR_NUM: sg_blend_factor = 16;
pub const sg_blend_factor__SG_BLENDFACTOR_FORCE_U32: sg_blend_factor = 2147483647;
pub type sg_blend_factor = ::std::os::raw::c_uint;
pub const sg_blend_op__SG_BLENDOP_DEFAULT: sg_blend_op = 0;
pub const sg_blend_op_SG_BLENDOP_ADD: sg_blend_op = 1;
pub const sg_blend_op_SG_BLENDOP_SUBTRACT: sg_blend_op = 2;
pub const sg_blend_op_SG_BLENDOP_REVERSE_SUBTRACT: sg_blend_op = 3;
pub const sg_blend_op__SG_BLENDOP_NUM: sg_blend_op = 4;
pub const sg_blend_op__SG_BLENDOP_FORCE_U32: sg_blend_op = 2147483647;
pub type sg_blend_op = ::std::os::raw::c_uint;
pub const sg_color_mask__SG_COLORMASK_DEFAULT: sg_color_mask = 0;
pub const sg_color_mask_SG_COLORMASK_NONE: sg_color_mask = 16;
pub const sg_color_mask_SG_COLORMASK_R: sg_color_mask = 1;
pub const sg_color_mask_SG_COLORMASK_G: sg_color_mask = 2;
pub const sg_color_mask_SG_COLORMASK_B: sg_color_mask = 4;
pub const sg_color_mask_SG_COLORMASK_A: sg_color_mask = 8;
pub const sg_color_mask_SG_COLORMASK_RGB: sg_color_mask = 7;
pub const sg_color_mask_SG_COLORMASK_RGBA: sg_color_mask = 15;
pub const sg_color_mask__SG_COLORMASK_FORCE_U32: sg_color_mask = 2147483647;
pub type sg_color_mask = ::std::os::raw::c_uint;
pub const sg_action__SG_ACTION_DEFAULT: sg_action = 0;
pub const sg_action_SG_ACTION_CLEAR: sg_action = 1;
pub const sg_action_SG_ACTION_LOAD: sg_action = 2;
pub const sg_action_SG_ACTION_DONTCARE: sg_action = 3;
pub const sg_action__SG_ACTION_NUM: sg_action = 4;
pub const sg_action__SG_ACTION_FORCE_U32: sg_action = 2147483647;
pub type sg_action = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_color_attachment_action {
    pub action: sg_action,
    pub val: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_sg_color_attachment_action() {
    assert_eq!(
        ::std::mem::size_of::<sg_color_attachment_action>(),
        20usize,
        concat!("Size of: ", stringify!(sg_color_attachment_action))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_color_attachment_action>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_color_attachment_action))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_color_attachment_action>())).action as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_color_attachment_action),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_color_attachment_action>())).val as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_color_attachment_action),
            "::",
            stringify!(val)
        )
    );
}
impl Default for sg_color_attachment_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_depth_attachment_action {
    pub action: sg_action,
    pub val: f32,
}
#[test]
fn bindgen_test_layout_sg_depth_attachment_action() {
    assert_eq!(
        ::std::mem::size_of::<sg_depth_attachment_action>(),
        8usize,
        concat!("Size of: ", stringify!(sg_depth_attachment_action))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_depth_attachment_action>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_depth_attachment_action))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_depth_attachment_action>())).action as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_attachment_action),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_depth_attachment_action>())).val as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_attachment_action),
            "::",
            stringify!(val)
        )
    );
}
impl Default for sg_depth_attachment_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_stencil_attachment_action {
    pub action: sg_action,
    pub val: u8,
}
#[test]
fn bindgen_test_layout_sg_stencil_attachment_action() {
    assert_eq!(
        ::std::mem::size_of::<sg_stencil_attachment_action>(),
        8usize,
        concat!("Size of: ", stringify!(sg_stencil_attachment_action))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_stencil_attachment_action>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_stencil_attachment_action))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_stencil_attachment_action>())).action as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_attachment_action),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_stencil_attachment_action>())).val as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_attachment_action),
            "::",
            stringify!(val)
        )
    );
}
impl Default for sg_stencil_attachment_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_pass_action {
    pub _start_canary: u32,
    pub colors: [sg_color_attachment_action; 4usize],
    pub depth: sg_depth_attachment_action,
    pub stencil: sg_stencil_attachment_action,
    pub _end_canary: u32,
}
#[test]
fn bindgen_test_layout_sg_pass_action() {
    assert_eq!(
        ::std::mem::size_of::<sg_pass_action>(),
        104usize,
        concat!("Size of: ", stringify!(sg_pass_action))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pass_action>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_pass_action))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_action>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_action),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_action>())).colors as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_action),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_action>())).depth as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_action),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_action>())).stencil as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_action),
            "::",
            stringify!(stencil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_action>()))._end_canary as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_action),
            "::",
            stringify!(_end_canary)
        )
    );
}
impl Default for sg_pass_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sg_bindings {
    pub _start_canary: u32,
    pub vertex_buffers: [sg_buffer; 8usize],
    pub vertex_buffer_offsets: [::std::os::raw::c_int; 8usize],
    pub index_buffer: sg_buffer,
    pub index_buffer_offset: ::std::os::raw::c_int,
    pub vs_images: [sg_image; 12usize],
    pub fs_images: [sg_image; 12usize],
    pub _end_canary: u32,
}
#[test]
fn bindgen_test_layout_sg_bindings() {
    assert_eq!(
        ::std::mem::size_of::<sg_bindings>(),
        176usize,
        concat!("Size of: ", stringify!(sg_bindings))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_bindings>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_bindings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_bindings>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_bindings>())).vertex_buffers as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(vertex_buffers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_bindings>())).vertex_buffer_offsets as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(vertex_buffer_offsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_bindings>())).index_buffer as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(index_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_bindings>())).index_buffer_offset as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(index_buffer_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_bindings>())).vs_images as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(vs_images)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_bindings>())).fs_images as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(fs_images)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_bindings>()))._end_canary as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_bindings),
            "::",
            stringify!(_end_canary)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_buffer_desc {
    pub _start_canary: u32,
    pub size: ::std::os::raw::c_int,
    pub type_: sg_buffer_type,
    pub usage: sg_usage,
    pub content: *const ::std::os::raw::c_void,
    pub label: *const ::std::os::raw::c_char,
    pub gl_buffers: [u32; 2usize],
    pub mtl_buffers: [*const ::std::os::raw::c_void; 2usize],
    pub d3d11_buffer: *const ::std::os::raw::c_void,
    pub wgpu_buffer: *const ::std::os::raw::c_void,
    pub _end_canary: u32,
}
#[test]
fn bindgen_test_layout_sg_buffer_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_buffer_desc>(),
        80usize,
        concat!("Size of: ", stringify!(sg_buffer_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_buffer_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_buffer_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).usage as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).content as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).label as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).gl_buffers as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(gl_buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).mtl_buffers as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(mtl_buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).d3d11_buffer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(d3d11_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>())).wgpu_buffer as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(wgpu_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_desc>()))._end_canary as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_desc),
            "::",
            stringify!(_end_canary)
        )
    );
}
impl Default for sg_buffer_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_subimage_content {
    pub ptr: *const ::std::os::raw::c_void,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sg_subimage_content() {
    assert_eq!(
        ::std::mem::size_of::<sg_subimage_content>(),
        16usize,
        concat!("Size of: ", stringify!(sg_subimage_content))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_subimage_content>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_subimage_content))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_subimage_content>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_subimage_content),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_subimage_content>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_subimage_content),
            "::",
            stringify!(size)
        )
    );
}
impl Default for sg_subimage_content {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_image_content {
    pub subimage: [[sg_subimage_content; 16usize]; 6usize],
}
#[test]
fn bindgen_test_layout_sg_image_content() {
    assert_eq!(
        ::std::mem::size_of::<sg_image_content>(),
        1536usize,
        concat!("Size of: ", stringify!(sg_image_content))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_image_content>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_image_content))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_content>())).subimage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_content),
            "::",
            stringify!(subimage)
        )
    );
}
impl Default for sg_image_content {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_image_desc {
    pub _start_canary: u32,
    pub type_: sg_image_type,
    pub render_target: bool,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub __bindgen_anon_1: sg_image_desc__bindgen_ty_1,
    pub num_mipmaps: ::std::os::raw::c_int,
    pub usage: sg_usage,
    pub pixel_format: sg_pixel_format,
    pub sample_count: ::std::os::raw::c_int,
    pub min_filter: sg_filter,
    pub mag_filter: sg_filter,
    pub wrap_u: sg_wrap,
    pub wrap_v: sg_wrap,
    pub wrap_w: sg_wrap,
    pub border_color: sg_border_color,
    pub max_anisotropy: u32,
    pub min_lod: f32,
    pub max_lod: f32,
    pub content: sg_image_content,
    pub label: *const ::std::os::raw::c_char,
    pub gl_textures: [u32; 2usize],
    pub gl_texture_target: u32,
    pub mtl_textures: [*const ::std::os::raw::c_void; 2usize],
    pub d3d11_texture: *const ::std::os::raw::c_void,
    pub d3d11_shader_resource_view: *const ::std::os::raw::c_void,
    pub wgpu_texture: *const ::std::os::raw::c_void,
    pub _end_canary: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sg_image_desc__bindgen_ty_1 {
    pub depth: ::std::os::raw::c_int,
    pub layers: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sg_image_desc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sg_image_desc__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(sg_image_desc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_image_desc__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_image_desc__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_image_desc__bindgen_ty_1>())).depth as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc__bindgen_ty_1),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_image_desc__bindgen_ty_1>())).layers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc__bindgen_ty_1),
            "::",
            stringify!(layers)
        )
    );
}
impl Default for sg_image_desc__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sg_image_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_image_desc>(),
        1688usize,
        concat!("Size of: ", stringify!(sg_image_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_image_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_image_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).render_target as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(render_target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).num_mipmaps as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(num_mipmaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).usage as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).pixel_format as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).sample_count as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(sample_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).min_filter as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(min_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).mag_filter as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(mag_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).wrap_u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(wrap_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).wrap_v as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(wrap_v)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).wrap_w as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(wrap_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).border_color as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(border_color)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).max_anisotropy as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(max_anisotropy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).min_lod as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(min_lod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).max_lod as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(max_lod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).content as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).label as *const _ as usize },
        1616usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).gl_textures as *const _ as usize },
        1624usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(gl_textures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).gl_texture_target as *const _ as usize },
        1632usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(gl_texture_target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).mtl_textures as *const _ as usize },
        1640usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(mtl_textures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).d3d11_texture as *const _ as usize },
        1656usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(d3d11_texture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_image_desc>())).d3d11_shader_resource_view as *const _
                as usize
        },
        1664usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(d3d11_shader_resource_view)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>())).wgpu_texture as *const _ as usize },
        1672usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(wgpu_texture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_desc>()))._end_canary as *const _ as usize },
        1680usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_desc),
            "::",
            stringify!(_end_canary)
        )
    );
}
impl Default for sg_image_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_shader_attr_desc {
    pub name: *const ::std::os::raw::c_char,
    pub sem_name: *const ::std::os::raw::c_char,
    pub sem_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sg_shader_attr_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader_attr_desc>(),
        24usize,
        concat!("Size of: ", stringify!(sg_shader_attr_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader_attr_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_shader_attr_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_attr_desc>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_attr_desc),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_attr_desc>())).sem_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_attr_desc),
            "::",
            stringify!(sem_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_attr_desc>())).sem_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_attr_desc),
            "::",
            stringify!(sem_index)
        )
    );
}
impl Default for sg_shader_attr_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_shader_uniform_desc {
    pub name: *const ::std::os::raw::c_char,
    pub type_: sg_uniform_type,
    pub array_count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sg_shader_uniform_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader_uniform_desc>(),
        16usize,
        concat!("Size of: ", stringify!(sg_shader_uniform_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader_uniform_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_shader_uniform_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_uniform_desc>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_uniform_desc),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_uniform_desc>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_uniform_desc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_shader_uniform_desc>())).array_count as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_uniform_desc),
            "::",
            stringify!(array_count)
        )
    );
}
impl Default for sg_shader_uniform_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_shader_uniform_block_desc {
    pub size: ::std::os::raw::c_int,
    pub uniforms: [sg_shader_uniform_desc; 16usize],
}
#[test]
fn bindgen_test_layout_sg_shader_uniform_block_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader_uniform_block_desc>(),
        264usize,
        concat!("Size of: ", stringify!(sg_shader_uniform_block_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader_uniform_block_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_shader_uniform_block_desc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_shader_uniform_block_desc>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_uniform_block_desc),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_shader_uniform_block_desc>())).uniforms as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_uniform_block_desc),
            "::",
            stringify!(uniforms)
        )
    );
}
impl Default for sg_shader_uniform_block_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_shader_image_desc {
    pub name: *const ::std::os::raw::c_char,
    pub type_: sg_image_type,
    pub sampler_type: sg_sampler_type,
}
#[test]
fn bindgen_test_layout_sg_shader_image_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader_image_desc>(),
        16usize,
        concat!("Size of: ", stringify!(sg_shader_image_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader_image_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_shader_image_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_image_desc>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_image_desc),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_image_desc>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_image_desc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_shader_image_desc>())).sampler_type as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_image_desc),
            "::",
            stringify!(sampler_type)
        )
    );
}
impl Default for sg_shader_image_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_shader_stage_desc {
    pub source: *const ::std::os::raw::c_char,
    pub byte_code: *const u8,
    pub byte_code_size: ::std::os::raw::c_int,
    pub entry: *const ::std::os::raw::c_char,
    pub d3d11_target: *const ::std::os::raw::c_char,
    pub uniform_blocks: [sg_shader_uniform_block_desc; 4usize],
    pub images: [sg_shader_image_desc; 12usize],
}
#[test]
fn bindgen_test_layout_sg_shader_stage_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader_stage_desc>(),
        1288usize,
        concat!("Size of: ", stringify!(sg_shader_stage_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader_stage_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_shader_stage_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_stage_desc>())).source as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_stage_desc),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_stage_desc>())).byte_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_stage_desc),
            "::",
            stringify!(byte_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_shader_stage_desc>())).byte_code_size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_stage_desc),
            "::",
            stringify!(byte_code_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_stage_desc>())).entry as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_stage_desc),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_shader_stage_desc>())).d3d11_target as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_stage_desc),
            "::",
            stringify!(d3d11_target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_shader_stage_desc>())).uniform_blocks as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_stage_desc),
            "::",
            stringify!(uniform_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_stage_desc>())).images as *const _ as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_stage_desc),
            "::",
            stringify!(images)
        )
    );
}
impl Default for sg_shader_stage_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_shader_desc {
    pub _start_canary: u32,
    pub attrs: [sg_shader_attr_desc; 16usize],
    pub vs: sg_shader_stage_desc,
    pub fs: sg_shader_stage_desc,
    pub label: *const ::std::os::raw::c_char,
    pub _end_canary: u32,
}
#[test]
fn bindgen_test_layout_sg_shader_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader_desc>(),
        2984usize,
        concat!("Size of: ", stringify!(sg_shader_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_shader_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_desc>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_desc),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_desc>())).attrs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_desc),
            "::",
            stringify!(attrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_desc>())).vs as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_desc),
            "::",
            stringify!(vs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_desc>())).fs as *const _ as usize },
        1680usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_desc),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_desc>())).label as *const _ as usize },
        2968usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_desc),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_desc>()))._end_canary as *const _ as usize },
        2976usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_desc),
            "::",
            stringify!(_end_canary)
        )
    );
}
impl Default for sg_shader_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_buffer_layout_desc {
    pub stride: ::std::os::raw::c_int,
    pub step_func: sg_vertex_step,
    pub step_rate: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sg_buffer_layout_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_buffer_layout_desc>(),
        12usize,
        concat!("Size of: ", stringify!(sg_buffer_layout_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_buffer_layout_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_buffer_layout_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_layout_desc>())).stride as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_layout_desc),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_layout_desc>())).step_func as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_layout_desc),
            "::",
            stringify!(step_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_layout_desc>())).step_rate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_layout_desc),
            "::",
            stringify!(step_rate)
        )
    );
}
impl Default for sg_buffer_layout_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_vertex_attr_desc {
    pub buffer_index: ::std::os::raw::c_int,
    pub offset: ::std::os::raw::c_int,
    pub format: sg_vertex_format,
}
#[test]
fn bindgen_test_layout_sg_vertex_attr_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_vertex_attr_desc>(),
        12usize,
        concat!("Size of: ", stringify!(sg_vertex_attr_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_vertex_attr_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_vertex_attr_desc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_vertex_attr_desc>())).buffer_index as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_vertex_attr_desc),
            "::",
            stringify!(buffer_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_vertex_attr_desc>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_vertex_attr_desc),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_vertex_attr_desc>())).format as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_vertex_attr_desc),
            "::",
            stringify!(format)
        )
    );
}
impl Default for sg_vertex_attr_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_layout_desc {
    pub buffers: [sg_buffer_layout_desc; 8usize],
    pub attrs: [sg_vertex_attr_desc; 16usize],
}
#[test]
fn bindgen_test_layout_sg_layout_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_layout_desc>(),
        288usize,
        concat!("Size of: ", stringify!(sg_layout_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_layout_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_layout_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_layout_desc>())).buffers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_layout_desc),
            "::",
            stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_layout_desc>())).attrs as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_layout_desc),
            "::",
            stringify!(attrs)
        )
    );
}
impl Default for sg_layout_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_stencil_state {
    pub fail_op: sg_stencil_op,
    pub depth_fail_op: sg_stencil_op,
    pub pass_op: sg_stencil_op,
    pub compare_func: sg_compare_func,
}
#[test]
fn bindgen_test_layout_sg_stencil_state() {
    assert_eq!(
        ::std::mem::size_of::<sg_stencil_state>(),
        16usize,
        concat!("Size of: ", stringify!(sg_stencil_state))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_stencil_state>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_stencil_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_stencil_state>())).fail_op as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_state),
            "::",
            stringify!(fail_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_stencil_state>())).depth_fail_op as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_state),
            "::",
            stringify!(depth_fail_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_stencil_state>())).pass_op as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_state),
            "::",
            stringify!(pass_op)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_stencil_state>())).compare_func as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_stencil_state),
            "::",
            stringify!(compare_func)
        )
    );
}
impl Default for sg_stencil_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_depth_stencil_state {
    pub stencil_front: sg_stencil_state,
    pub stencil_back: sg_stencil_state,
    pub depth_compare_func: sg_compare_func,
    pub depth_write_enabled: bool,
    pub stencil_enabled: bool,
    pub stencil_read_mask: u8,
    pub stencil_write_mask: u8,
    pub stencil_ref: u8,
}
#[test]
fn bindgen_test_layout_sg_depth_stencil_state() {
    assert_eq!(
        ::std::mem::size_of::<sg_depth_stencil_state>(),
        44usize,
        concat!("Size of: ", stringify!(sg_depth_stencil_state))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_depth_stencil_state>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_depth_stencil_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_depth_stencil_state>())).stencil_front as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_stencil_state),
            "::",
            stringify!(stencil_front)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_depth_stencil_state>())).stencil_back as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_stencil_state),
            "::",
            stringify!(stencil_back)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_depth_stencil_state>())).depth_compare_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_stencil_state),
            "::",
            stringify!(depth_compare_func)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_depth_stencil_state>())).depth_write_enabled as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_stencil_state),
            "::",
            stringify!(depth_write_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_depth_stencil_state>())).stencil_enabled as *const _ as usize
        },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_stencil_state),
            "::",
            stringify!(stencil_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_depth_stencil_state>())).stencil_read_mask as *const _
                as usize
        },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_stencil_state),
            "::",
            stringify!(stencil_read_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_depth_stencil_state>())).stencil_write_mask as *const _
                as usize
        },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_stencil_state),
            "::",
            stringify!(stencil_write_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_depth_stencil_state>())).stencil_ref as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_depth_stencil_state),
            "::",
            stringify!(stencil_ref)
        )
    );
}
impl Default for sg_depth_stencil_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_blend_state {
    pub enabled: bool,
    pub src_factor_rgb: sg_blend_factor,
    pub dst_factor_rgb: sg_blend_factor,
    pub op_rgb: sg_blend_op,
    pub src_factor_alpha: sg_blend_factor,
    pub dst_factor_alpha: sg_blend_factor,
    pub op_alpha: sg_blend_op,
    pub color_write_mask: u8,
    pub color_attachment_count: ::std::os::raw::c_int,
    pub color_format: sg_pixel_format,
    pub depth_format: sg_pixel_format,
    pub blend_color: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_sg_blend_state() {
    assert_eq!(
        ::std::mem::size_of::<sg_blend_state>(),
        60usize,
        concat!("Size of: ", stringify!(sg_blend_state))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_blend_state>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_blend_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).enabled as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).src_factor_rgb as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(src_factor_rgb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).dst_factor_rgb as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(dst_factor_rgb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).op_rgb as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(op_rgb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).src_factor_alpha as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(src_factor_alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).dst_factor_alpha as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(dst_factor_alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).op_alpha as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(op_alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).color_write_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(color_write_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_blend_state>())).color_attachment_count as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(color_attachment_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).color_format as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(color_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).depth_format as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(depth_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_blend_state>())).blend_color as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_blend_state),
            "::",
            stringify!(blend_color)
        )
    );
}
impl Default for sg_blend_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_rasterizer_state {
    pub alpha_to_coverage_enabled: bool,
    pub cull_mode: sg_cull_mode,
    pub face_winding: sg_face_winding,
    pub sample_count: ::std::os::raw::c_int,
    pub depth_bias: f32,
    pub depth_bias_slope_scale: f32,
    pub depth_bias_clamp: f32,
}
#[test]
fn bindgen_test_layout_sg_rasterizer_state() {
    assert_eq!(
        ::std::mem::size_of::<sg_rasterizer_state>(),
        28usize,
        concat!("Size of: ", stringify!(sg_rasterizer_state))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_rasterizer_state>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_rasterizer_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_rasterizer_state>())).alpha_to_coverage_enabled as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_rasterizer_state),
            "::",
            stringify!(alpha_to_coverage_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_rasterizer_state>())).cull_mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_rasterizer_state),
            "::",
            stringify!(cull_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_rasterizer_state>())).face_winding as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_rasterizer_state),
            "::",
            stringify!(face_winding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_rasterizer_state>())).sample_count as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_rasterizer_state),
            "::",
            stringify!(sample_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_rasterizer_state>())).depth_bias as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_rasterizer_state),
            "::",
            stringify!(depth_bias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_rasterizer_state>())).depth_bias_slope_scale as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_rasterizer_state),
            "::",
            stringify!(depth_bias_slope_scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_rasterizer_state>())).depth_bias_clamp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_rasterizer_state),
            "::",
            stringify!(depth_bias_clamp)
        )
    );
}
impl Default for sg_rasterizer_state {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_pipeline_desc {
    pub _start_canary: u32,
    pub layout: sg_layout_desc,
    pub shader: sg_shader,
    pub primitive_type: sg_primitive_type,
    pub index_type: sg_index_type,
    pub depth_stencil: sg_depth_stencil_state,
    pub blend: sg_blend_state,
    pub rasterizer: sg_rasterizer_state,
    pub label: *const ::std::os::raw::c_char,
    pub _end_canary: u32,
}
#[test]
fn bindgen_test_layout_sg_pipeline_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_pipeline_desc>(),
        456usize,
        concat!("Size of: ", stringify!(sg_pipeline_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pipeline_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_pipeline_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).layout as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).shader as *const _ as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).primitive_type as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(primitive_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).index_type as *const _ as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(index_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).depth_stencil as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(depth_stencil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).blend as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(blend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).rasterizer as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(rasterizer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>())).label as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_desc>()))._end_canary as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_desc),
            "::",
            stringify!(_end_canary)
        )
    );
}
impl Default for sg_pipeline_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_attachment_desc {
    pub image: sg_image,
    pub mip_level: ::std::os::raw::c_int,
    pub __bindgen_anon_1: sg_attachment_desc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sg_attachment_desc__bindgen_ty_1 {
    pub face: ::std::os::raw::c_int,
    pub layer: ::std::os::raw::c_int,
    pub slice: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sg_attachment_desc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<sg_attachment_desc__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(sg_attachment_desc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_attachment_desc__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(sg_attachment_desc__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_attachment_desc__bindgen_ty_1>())).face as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_attachment_desc__bindgen_ty_1),
            "::",
            stringify!(face)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_attachment_desc__bindgen_ty_1>())).layer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_attachment_desc__bindgen_ty_1),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_attachment_desc__bindgen_ty_1>())).slice as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_attachment_desc__bindgen_ty_1),
            "::",
            stringify!(slice)
        )
    );
}
impl Default for sg_attachment_desc__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sg_attachment_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_attachment_desc>(),
        12usize,
        concat!("Size of: ", stringify!(sg_attachment_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_attachment_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_attachment_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_attachment_desc>())).image as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_attachment_desc),
            "::",
            stringify!(image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_attachment_desc>())).mip_level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_attachment_desc),
            "::",
            stringify!(mip_level)
        )
    );
}
impl Default for sg_attachment_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_pass_desc {
    pub _start_canary: u32,
    pub color_attachments: [sg_attachment_desc; 4usize],
    pub depth_stencil_attachment: sg_attachment_desc,
    pub label: *const ::std::os::raw::c_char,
    pub _end_canary: u32,
}
#[test]
fn bindgen_test_layout_sg_pass_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_pass_desc>(),
        80usize,
        concat!("Size of: ", stringify!(sg_pass_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pass_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_pass_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_desc>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_desc),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_desc>())).color_attachments as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_desc),
            "::",
            stringify!(color_attachments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_pass_desc>())).depth_stencil_attachment as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_desc),
            "::",
            stringify!(depth_stencil_attachment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_desc>())).label as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_desc),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_desc>()))._end_canary as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_desc),
            "::",
            stringify!(_end_canary)
        )
    );
}
impl Default for sg_pass_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_trace_hooks {
    pub user_data: *mut ::std::os::raw::c_void,
    pub reset_state_cache:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub make_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            desc: *const sg_buffer_desc,
            result: sg_buffer,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub make_image: ::std::option::Option<
        unsafe extern "C" fn(
            desc: *const sg_image_desc,
            result: sg_image,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub make_shader: ::std::option::Option<
        unsafe extern "C" fn(
            desc: *const sg_shader_desc,
            result: sg_shader,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub make_pipeline: ::std::option::Option<
        unsafe extern "C" fn(
            desc: *const sg_pipeline_desc,
            result: sg_pipeline,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub make_pass: ::std::option::Option<
        unsafe extern "C" fn(
            desc: *const sg_pass_desc,
            result: sg_pass,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub destroy_buffer: ::std::option::Option<
        unsafe extern "C" fn(buf: sg_buffer, user_data: *mut ::std::os::raw::c_void),
    >,
    pub destroy_image: ::std::option::Option<
        unsafe extern "C" fn(img: sg_image, user_data: *mut ::std::os::raw::c_void),
    >,
    pub destroy_shader: ::std::option::Option<
        unsafe extern "C" fn(shd: sg_shader, user_data: *mut ::std::os::raw::c_void),
    >,
    pub destroy_pipeline: ::std::option::Option<
        unsafe extern "C" fn(pip: sg_pipeline, user_data: *mut ::std::os::raw::c_void),
    >,
    pub destroy_pass: ::std::option::Option<
        unsafe extern "C" fn(pass: sg_pass, user_data: *mut ::std::os::raw::c_void),
    >,
    pub update_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            buf: sg_buffer,
            data_ptr: *const ::std::os::raw::c_void,
            data_size: ::std::os::raw::c_int,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub update_image: ::std::option::Option<
        unsafe extern "C" fn(
            img: sg_image,
            data: *const sg_image_content,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub append_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            buf: sg_buffer,
            data_ptr: *const ::std::os::raw::c_void,
            data_size: ::std::os::raw::c_int,
            result: ::std::os::raw::c_int,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub begin_default_pass: ::std::option::Option<
        unsafe extern "C" fn(
            pass_action: *const sg_pass_action,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub begin_pass: ::std::option::Option<
        unsafe extern "C" fn(
            pass: sg_pass,
            pass_action: *const sg_pass_action,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub apply_viewport: ::std::option::Option<
        unsafe extern "C" fn(
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            origin_top_left: bool,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub apply_scissor_rect: ::std::option::Option<
        unsafe extern "C" fn(
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
            origin_top_left: bool,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub apply_pipeline: ::std::option::Option<
        unsafe extern "C" fn(pip: sg_pipeline, user_data: *mut ::std::os::raw::c_void),
    >,
    pub apply_bindings: ::std::option::Option<
        unsafe extern "C" fn(bindings: *const sg_bindings, user_data: *mut ::std::os::raw::c_void),
    >,
    pub apply_uniforms: ::std::option::Option<
        unsafe extern "C" fn(
            stage: sg_shader_stage,
            ub_index: ::std::os::raw::c_int,
            data: *const ::std::os::raw::c_void,
            num_bytes: ::std::os::raw::c_int,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub draw: ::std::option::Option<
        unsafe extern "C" fn(
            base_element: ::std::os::raw::c_int,
            num_elements: ::std::os::raw::c_int,
            num_instances: ::std::os::raw::c_int,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub end_pass:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub commit: ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub alloc_buffer: ::std::option::Option<
        unsafe extern "C" fn(result: sg_buffer, user_data: *mut ::std::os::raw::c_void),
    >,
    pub alloc_image: ::std::option::Option<
        unsafe extern "C" fn(result: sg_image, user_data: *mut ::std::os::raw::c_void),
    >,
    pub alloc_shader: ::std::option::Option<
        unsafe extern "C" fn(result: sg_shader, user_data: *mut ::std::os::raw::c_void),
    >,
    pub alloc_pipeline: ::std::option::Option<
        unsafe extern "C" fn(result: sg_pipeline, user_data: *mut ::std::os::raw::c_void),
    >,
    pub alloc_pass: ::std::option::Option<
        unsafe extern "C" fn(result: sg_pass, user_data: *mut ::std::os::raw::c_void),
    >,
    pub dealloc_buffer: ::std::option::Option<
        unsafe extern "C" fn(buf_id: sg_buffer, user_data: *mut ::std::os::raw::c_void),
    >,
    pub dealloc_image: ::std::option::Option<
        unsafe extern "C" fn(img_id: sg_image, user_data: *mut ::std::os::raw::c_void),
    >,
    pub dealloc_shader: ::std::option::Option<
        unsafe extern "C" fn(shd_id: sg_shader, user_data: *mut ::std::os::raw::c_void),
    >,
    pub dealloc_pipeline: ::std::option::Option<
        unsafe extern "C" fn(pip_id: sg_pipeline, user_data: *mut ::std::os::raw::c_void),
    >,
    pub dealloc_pass: ::std::option::Option<
        unsafe extern "C" fn(pass_id: sg_pass, user_data: *mut ::std::os::raw::c_void),
    >,
    pub init_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            buf_id: sg_buffer,
            desc: *const sg_buffer_desc,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub init_image: ::std::option::Option<
        unsafe extern "C" fn(
            img_id: sg_image,
            desc: *const sg_image_desc,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub init_shader: ::std::option::Option<
        unsafe extern "C" fn(
            shd_id: sg_shader,
            desc: *const sg_shader_desc,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub init_pipeline: ::std::option::Option<
        unsafe extern "C" fn(
            pip_id: sg_pipeline,
            desc: *const sg_pipeline_desc,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub init_pass: ::std::option::Option<
        unsafe extern "C" fn(
            pass_id: sg_pass,
            desc: *const sg_pass_desc,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub uninit_buffer: ::std::option::Option<
        unsafe extern "C" fn(buf_id: sg_buffer, user_data: *mut ::std::os::raw::c_void),
    >,
    pub uninit_image: ::std::option::Option<
        unsafe extern "C" fn(img_id: sg_image, user_data: *mut ::std::os::raw::c_void),
    >,
    pub uninit_shader: ::std::option::Option<
        unsafe extern "C" fn(shd_id: sg_shader, user_data: *mut ::std::os::raw::c_void),
    >,
    pub uninit_pipeline: ::std::option::Option<
        unsafe extern "C" fn(pip_id: sg_pipeline, user_data: *mut ::std::os::raw::c_void),
    >,
    pub uninit_pass: ::std::option::Option<
        unsafe extern "C" fn(pass_id: sg_pass, user_data: *mut ::std::os::raw::c_void),
    >,
    pub fail_buffer: ::std::option::Option<
        unsafe extern "C" fn(buf_id: sg_buffer, user_data: *mut ::std::os::raw::c_void),
    >,
    pub fail_image: ::std::option::Option<
        unsafe extern "C" fn(img_id: sg_image, user_data: *mut ::std::os::raw::c_void),
    >,
    pub fail_shader: ::std::option::Option<
        unsafe extern "C" fn(shd_id: sg_shader, user_data: *mut ::std::os::raw::c_void),
    >,
    pub fail_pipeline: ::std::option::Option<
        unsafe extern "C" fn(pip_id: sg_pipeline, user_data: *mut ::std::os::raw::c_void),
    >,
    pub fail_pass: ::std::option::Option<
        unsafe extern "C" fn(pass_id: sg_pass, user_data: *mut ::std::os::raw::c_void),
    >,
    pub push_debug_group: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            user_data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub pop_debug_group:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_buffer_pool_exhausted:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_image_pool_exhausted:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_shader_pool_exhausted:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_pipeline_pool_exhausted:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_pass_pool_exhausted:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_context_mismatch:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_pass_invalid:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_draw_invalid:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
    pub err_bindings_invalid:
        ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>,
}
#[test]
fn bindgen_test_layout_sg_trace_hooks() {
    assert_eq!(
        ::std::mem::size_of::<sg_trace_hooks>(),
        488usize,
        concat!("Size of: ", stringify!(sg_trace_hooks))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_trace_hooks>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_trace_hooks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).user_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).reset_state_cache as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(reset_state_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).make_buffer as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(make_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).make_image as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(make_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).make_shader as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(make_shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).make_pipeline as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(make_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).make_pass as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(make_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).destroy_buffer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(destroy_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).destroy_image as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(destroy_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).destroy_shader as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(destroy_shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).destroy_pipeline as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(destroy_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).destroy_pass as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(destroy_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).update_buffer as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(update_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).update_image as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(update_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).append_buffer as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(append_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).begin_default_pass as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(begin_default_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).begin_pass as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(begin_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).apply_viewport as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(apply_viewport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).apply_scissor_rect as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(apply_scissor_rect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).apply_pipeline as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(apply_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).apply_bindings as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(apply_bindings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).apply_uniforms as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(apply_uniforms)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).draw as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(draw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).end_pass as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(end_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).commit as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(commit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).alloc_buffer as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(alloc_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).alloc_image as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(alloc_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).alloc_shader as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(alloc_shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).alloc_pipeline as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(alloc_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).alloc_pass as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(alloc_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).dealloc_buffer as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(dealloc_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).dealloc_image as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(dealloc_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).dealloc_shader as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(dealloc_shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).dealloc_pipeline as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(dealloc_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).dealloc_pass as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(dealloc_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).init_buffer as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(init_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).init_image as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(init_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).init_shader as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(init_shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).init_pipeline as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(init_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).init_pass as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(init_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).uninit_buffer as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(uninit_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).uninit_image as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(uninit_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).uninit_shader as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(uninit_shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).uninit_pipeline as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(uninit_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).uninit_pass as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(uninit_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).fail_buffer as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(fail_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).fail_image as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(fail_image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).fail_shader as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(fail_shader)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).fail_pipeline as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(fail_pipeline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).fail_pass as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(fail_pass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).push_debug_group as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(push_debug_group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).pop_debug_group as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(pop_debug_group)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).err_buffer_pool_exhausted as *const _
                as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_buffer_pool_exhausted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).err_image_pool_exhausted as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_image_pool_exhausted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).err_shader_pool_exhausted as *const _
                as usize
        },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_shader_pool_exhausted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).err_pipeline_pool_exhausted as *const _
                as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_pipeline_pool_exhausted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).err_pass_pool_exhausted as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_pass_pool_exhausted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).err_context_mismatch as *const _ as usize
        },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_context_mismatch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).err_pass_invalid as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_pass_invalid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_trace_hooks>())).err_draw_invalid as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_draw_invalid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_trace_hooks>())).err_bindings_invalid as *const _ as usize
        },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_trace_hooks),
            "::",
            stringify!(err_bindings_invalid)
        )
    );
}
impl Default for sg_trace_hooks {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_slot_info {
    pub state: sg_resource_state,
    pub res_id: u32,
    pub ctx_id: u32,
}
#[test]
fn bindgen_test_layout_sg_slot_info() {
    assert_eq!(
        ::std::mem::size_of::<sg_slot_info>(),
        12usize,
        concat!("Size of: ", stringify!(sg_slot_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_slot_info>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_slot_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_slot_info>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_slot_info),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_slot_info>())).res_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_slot_info),
            "::",
            stringify!(res_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_slot_info>())).ctx_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_slot_info),
            "::",
            stringify!(ctx_id)
        )
    );
}
impl Default for sg_slot_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_buffer_info {
    pub slot: sg_slot_info,
    pub update_frame_index: u32,
    pub append_frame_index: u32,
    pub append_pos: ::std::os::raw::c_int,
    pub append_overflow: bool,
    pub num_slots: ::std::os::raw::c_int,
    pub active_slot: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sg_buffer_info() {
    assert_eq!(
        ::std::mem::size_of::<sg_buffer_info>(),
        36usize,
        concat!("Size of: ", stringify!(sg_buffer_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_buffer_info>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_buffer_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_info>())).slot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_info),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_buffer_info>())).update_frame_index as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_info),
            "::",
            stringify!(update_frame_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_buffer_info>())).append_frame_index as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_info),
            "::",
            stringify!(append_frame_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_info>())).append_pos as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_info),
            "::",
            stringify!(append_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_info>())).append_overflow as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_info),
            "::",
            stringify!(append_overflow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_info>())).num_slots as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_info),
            "::",
            stringify!(num_slots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_buffer_info>())).active_slot as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_buffer_info),
            "::",
            stringify!(active_slot)
        )
    );
}
impl Default for sg_buffer_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_image_info {
    pub slot: sg_slot_info,
    pub upd_frame_index: u32,
    pub num_slots: ::std::os::raw::c_int,
    pub active_slot: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sg_image_info() {
    assert_eq!(
        ::std::mem::size_of::<sg_image_info>(),
        32usize,
        concat!("Size of: ", stringify!(sg_image_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_image_info>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_image_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_info>())).slot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_info),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_info>())).upd_frame_index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_info),
            "::",
            stringify!(upd_frame_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_info>())).num_slots as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_info),
            "::",
            stringify!(num_slots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_info>())).active_slot as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_info),
            "::",
            stringify!(active_slot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_info>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_image_info>())).height as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_image_info),
            "::",
            stringify!(height)
        )
    );
}
impl Default for sg_image_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_shader_info {
    pub slot: sg_slot_info,
}
#[test]
fn bindgen_test_layout_sg_shader_info() {
    assert_eq!(
        ::std::mem::size_of::<sg_shader_info>(),
        12usize,
        concat!("Size of: ", stringify!(sg_shader_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_shader_info>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_shader_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_shader_info>())).slot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_shader_info),
            "::",
            stringify!(slot)
        )
    );
}
impl Default for sg_shader_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_pipeline_info {
    pub slot: sg_slot_info,
}
#[test]
fn bindgen_test_layout_sg_pipeline_info() {
    assert_eq!(
        ::std::mem::size_of::<sg_pipeline_info>(),
        12usize,
        concat!("Size of: ", stringify!(sg_pipeline_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pipeline_info>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_pipeline_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pipeline_info>())).slot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pipeline_info),
            "::",
            stringify!(slot)
        )
    );
}
impl Default for sg_pipeline_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_pass_info {
    pub slot: sg_slot_info,
}
#[test]
fn bindgen_test_layout_sg_pass_info() {
    assert_eq!(
        ::std::mem::size_of::<sg_pass_info>(),
        12usize,
        concat!("Size of: ", stringify!(sg_pass_info))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_pass_info>(),
        4usize,
        concat!("Alignment of ", stringify!(sg_pass_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_pass_info>())).slot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_pass_info),
            "::",
            stringify!(slot)
        )
    );
}
impl Default for sg_pass_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sg_gl_context_desc {
    pub force_gles2: bool,
}
#[test]
fn bindgen_test_layout_sg_gl_context_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_gl_context_desc>(),
        1usize,
        concat!("Size of: ", stringify!(sg_gl_context_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_gl_context_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(sg_gl_context_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_gl_context_desc>())).force_gles2 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_gl_context_desc),
            "::",
            stringify!(force_gles2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_mtl_context_desc {
    pub device: *const ::std::os::raw::c_void,
    pub renderpass_descriptor_cb:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_void>,
    pub renderpass_descriptor_userdata_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub drawable_cb: ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_void>,
    pub drawable_userdata_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sg_mtl_context_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_mtl_context_desc>(),
        48usize,
        concat!("Size of: ", stringify!(sg_mtl_context_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_mtl_context_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_mtl_context_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_mtl_context_desc>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_mtl_context_desc),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_mtl_context_desc>())).renderpass_descriptor_cb as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_mtl_context_desc),
            "::",
            stringify!(renderpass_descriptor_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_mtl_context_desc>())).renderpass_descriptor_userdata_cb
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_mtl_context_desc),
            "::",
            stringify!(renderpass_descriptor_userdata_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_mtl_context_desc>())).drawable_cb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_mtl_context_desc),
            "::",
            stringify!(drawable_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_mtl_context_desc>())).drawable_userdata_cb as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_mtl_context_desc),
            "::",
            stringify!(drawable_userdata_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_mtl_context_desc>())).user_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_mtl_context_desc),
            "::",
            stringify!(user_data)
        )
    );
}
impl Default for sg_mtl_context_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type sg_metal_context_desc = sg_mtl_context_desc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_d3d11_context_desc {
    pub device: *const ::std::os::raw::c_void,
    pub device_context: *const ::std::os::raw::c_void,
    pub render_target_view_cb:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_void>,
    pub render_target_view_userdata_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub depth_stencil_view_cb:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_void>,
    pub depth_stencil_view_userdata_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sg_d3d11_context_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_d3d11_context_desc>(),
        56usize,
        concat!("Size of: ", stringify!(sg_d3d11_context_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_d3d11_context_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_d3d11_context_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_d3d11_context_desc>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_d3d11_context_desc),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_d3d11_context_desc>())).device_context as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_d3d11_context_desc),
            "::",
            stringify!(device_context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_d3d11_context_desc>())).render_target_view_cb as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_d3d11_context_desc),
            "::",
            stringify!(render_target_view_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_d3d11_context_desc>())).render_target_view_userdata_cb
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_d3d11_context_desc),
            "::",
            stringify!(render_target_view_userdata_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_d3d11_context_desc>())).depth_stencil_view_cb as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_d3d11_context_desc),
            "::",
            stringify!(depth_stencil_view_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_d3d11_context_desc>())).depth_stencil_view_userdata_cb
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_d3d11_context_desc),
            "::",
            stringify!(depth_stencil_view_userdata_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_d3d11_context_desc>())).user_data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_d3d11_context_desc),
            "::",
            stringify!(user_data)
        )
    );
}
impl Default for sg_d3d11_context_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_wgpu_context_desc {
    pub device: *const ::std::os::raw::c_void,
    pub render_view_cb:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_void>,
    pub render_view_userdata_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub resolve_view_cb:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_void>,
    pub resolve_view_userdata_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub depth_stencil_view_cb:
        ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_void>,
    pub depth_stencil_view_userdata_cb: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_void,
    >,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sg_wgpu_context_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_wgpu_context_desc>(),
        64usize,
        concat!("Size of: ", stringify!(sg_wgpu_context_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_wgpu_context_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_wgpu_context_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_wgpu_context_desc>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_wgpu_context_desc>())).render_view_cb as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(render_view_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_wgpu_context_desc>())).render_view_userdata_cb as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(render_view_userdata_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_wgpu_context_desc>())).resolve_view_cb as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(resolve_view_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_wgpu_context_desc>())).resolve_view_userdata_cb as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(resolve_view_userdata_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_wgpu_context_desc>())).depth_stencil_view_cb as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(depth_stencil_view_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sg_wgpu_context_desc>())).depth_stencil_view_userdata_cb
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(depth_stencil_view_userdata_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_wgpu_context_desc>())).user_data as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_wgpu_context_desc),
            "::",
            stringify!(user_data)
        )
    );
}
impl Default for sg_wgpu_context_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_context_desc {
    pub color_format: sg_pixel_format,
    pub depth_format: sg_pixel_format,
    pub sample_count: ::std::os::raw::c_int,
    pub gl: sg_gl_context_desc,
    pub metal: sg_metal_context_desc,
    pub d3d11: sg_d3d11_context_desc,
    pub wgpu: sg_wgpu_context_desc,
}
#[test]
fn bindgen_test_layout_sg_context_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_context_desc>(),
        184usize,
        concat!("Size of: ", stringify!(sg_context_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_context_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_context_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context_desc>())).color_format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context_desc),
            "::",
            stringify!(color_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context_desc>())).depth_format as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context_desc),
            "::",
            stringify!(depth_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context_desc>())).sample_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context_desc),
            "::",
            stringify!(sample_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context_desc>())).gl as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context_desc),
            "::",
            stringify!(gl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context_desc>())).metal as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context_desc),
            "::",
            stringify!(metal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context_desc>())).d3d11 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context_desc),
            "::",
            stringify!(d3d11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_context_desc>())).wgpu as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_context_desc),
            "::",
            stringify!(wgpu)
        )
    );
}
impl Default for sg_context_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sg_desc {
    pub _start_canary: u32,
    pub buffer_pool_size: ::std::os::raw::c_int,
    pub image_pool_size: ::std::os::raw::c_int,
    pub shader_pool_size: ::std::os::raw::c_int,
    pub pipeline_pool_size: ::std::os::raw::c_int,
    pub pass_pool_size: ::std::os::raw::c_int,
    pub context_pool_size: ::std::os::raw::c_int,
    pub uniform_buffer_size: ::std::os::raw::c_int,
    pub staging_buffer_size: ::std::os::raw::c_int,
    pub sampler_cache_size: ::std::os::raw::c_int,
    pub context: sg_context_desc,
    pub _end_canary: u32,
}
#[test]
fn bindgen_test_layout_sg_desc() {
    assert_eq!(
        ::std::mem::size_of::<sg_desc>(),
        232usize,
        concat!("Size of: ", stringify!(sg_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<sg_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(sg_desc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>()))._start_canary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(_start_canary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).buffer_pool_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(buffer_pool_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).image_pool_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(image_pool_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).shader_pool_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(shader_pool_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).pipeline_pool_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(pipeline_pool_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).pass_pool_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(pass_pool_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).context_pool_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(context_pool_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).uniform_buffer_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(uniform_buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).staging_buffer_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(staging_buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).sampler_cache_size as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(sampler_cache_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>())).context as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sg_desc>()))._end_canary as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(sg_desc),
            "::",
            stringify!(_end_canary)
        )
    );
}
impl Default for sg_desc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn sg_setup(desc: *const sg_desc);
}
extern "C" {
    pub fn sg_shutdown();
}
extern "C" {
    pub fn sg_isvalid() -> bool;
}
extern "C" {
    pub fn sg_reset_state_cache();
}
extern "C" {
    pub fn sg_install_trace_hooks(trace_hooks: *const sg_trace_hooks) -> sg_trace_hooks;
}
extern "C" {
    pub fn sg_push_debug_group(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sg_pop_debug_group();
}
extern "C" {
    pub fn sg_make_buffer(desc: *const sg_buffer_desc) -> sg_buffer;
}
extern "C" {
    pub fn sg_make_image(desc: *const sg_image_desc) -> sg_image;
}
extern "C" {
    pub fn sg_make_shader(desc: *const sg_shader_desc) -> sg_shader;
}
extern "C" {
    pub fn sg_make_pipeline(desc: *const sg_pipeline_desc) -> sg_pipeline;
}
extern "C" {
    pub fn sg_make_pass(desc: *const sg_pass_desc) -> sg_pass;
}
extern "C" {
    pub fn sg_destroy_buffer(buf: sg_buffer);
}
extern "C" {
    pub fn sg_destroy_image(img: sg_image);
}
extern "C" {
    pub fn sg_destroy_shader(shd: sg_shader);
}
extern "C" {
    pub fn sg_destroy_pipeline(pip: sg_pipeline);
}
extern "C" {
    pub fn sg_destroy_pass(pass: sg_pass);
}
extern "C" {
    pub fn sg_update_buffer(
        buf: sg_buffer,
        data_ptr: *const ::std::os::raw::c_void,
        data_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn sg_update_image(img: sg_image, data: *const sg_image_content);
}
extern "C" {
    pub fn sg_append_buffer(
        buf: sg_buffer,
        data_ptr: *const ::std::os::raw::c_void,
        data_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sg_query_buffer_overflow(buf: sg_buffer) -> bool;
}
extern "C" {
    pub fn sg_begin_default_pass(
        pass_action: *const sg_pass_action,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn sg_begin_pass(pass: sg_pass, pass_action: *const sg_pass_action);
}
extern "C" {
    pub fn sg_apply_viewport(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        origin_top_left: bool,
    );
}
extern "C" {
    pub fn sg_apply_scissor_rect(
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        origin_top_left: bool,
    );
}
extern "C" {
    pub fn sg_apply_pipeline(pip: sg_pipeline);
}
extern "C" {
    pub fn sg_apply_bindings(bindings: *const sg_bindings);
}
extern "C" {
    pub fn sg_apply_uniforms(
        stage: sg_shader_stage,
        ub_index: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
        num_bytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn sg_draw(
        base_element: ::std::os::raw::c_int,
        num_elements: ::std::os::raw::c_int,
        num_instances: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn sg_end_pass();
}
extern "C" {
    pub fn sg_commit();
}
extern "C" {
    pub fn sg_query_desc() -> sg_desc;
}
extern "C" {
    pub fn sg_query_backend() -> sg_backend;
}
extern "C" {
    pub fn sg_query_features() -> sg_features;
}
extern "C" {
    pub fn sg_query_limits() -> sg_limits;
}
extern "C" {
    pub fn sg_query_pixelformat(fmt: sg_pixel_format) -> sg_pixelformat_info;
}
extern "C" {
    pub fn sg_query_buffer_state(buf: sg_buffer) -> sg_resource_state;
}
extern "C" {
    pub fn sg_query_image_state(img: sg_image) -> sg_resource_state;
}
extern "C" {
    pub fn sg_query_shader_state(shd: sg_shader) -> sg_resource_state;
}
extern "C" {
    pub fn sg_query_pipeline_state(pip: sg_pipeline) -> sg_resource_state;
}
extern "C" {
    pub fn sg_query_pass_state(pass: sg_pass) -> sg_resource_state;
}
extern "C" {
    pub fn sg_query_buffer_info(buf: sg_buffer) -> sg_buffer_info;
}
extern "C" {
    pub fn sg_query_image_info(img: sg_image) -> sg_image_info;
}
extern "C" {
    pub fn sg_query_shader_info(shd: sg_shader) -> sg_shader_info;
}
extern "C" {
    pub fn sg_query_pipeline_info(pip: sg_pipeline) -> sg_pipeline_info;
}
extern "C" {
    pub fn sg_query_pass_info(pass: sg_pass) -> sg_pass_info;
}
extern "C" {
    pub fn sg_query_buffer_defaults(desc: *const sg_buffer_desc) -> sg_buffer_desc;
}
extern "C" {
    pub fn sg_query_image_defaults(desc: *const sg_image_desc) -> sg_image_desc;
}
extern "C" {
    pub fn sg_query_shader_defaults(desc: *const sg_shader_desc) -> sg_shader_desc;
}
extern "C" {
    pub fn sg_query_pipeline_defaults(desc: *const sg_pipeline_desc) -> sg_pipeline_desc;
}
extern "C" {
    pub fn sg_query_pass_defaults(desc: *const sg_pass_desc) -> sg_pass_desc;
}
extern "C" {
    pub fn sg_alloc_buffer() -> sg_buffer;
}
extern "C" {
    pub fn sg_alloc_image() -> sg_image;
}
extern "C" {
    pub fn sg_alloc_shader() -> sg_shader;
}
extern "C" {
    pub fn sg_alloc_pipeline() -> sg_pipeline;
}
extern "C" {
    pub fn sg_alloc_pass() -> sg_pass;
}
extern "C" {
    pub fn sg_dealloc_buffer(buf_id: sg_buffer);
}
extern "C" {
    pub fn sg_dealloc_image(img_id: sg_image);
}
extern "C" {
    pub fn sg_dealloc_shader(shd_id: sg_shader);
}
extern "C" {
    pub fn sg_dealloc_pipeline(pip_id: sg_pipeline);
}
extern "C" {
    pub fn sg_dealloc_pass(pass_id: sg_pass);
}
extern "C" {
    pub fn sg_init_buffer(buf_id: sg_buffer, desc: *const sg_buffer_desc);
}
extern "C" {
    pub fn sg_init_image(img_id: sg_image, desc: *const sg_image_desc);
}
extern "C" {
    pub fn sg_init_shader(shd_id: sg_shader, desc: *const sg_shader_desc);
}
extern "C" {
    pub fn sg_init_pipeline(pip_id: sg_pipeline, desc: *const sg_pipeline_desc);
}
extern "C" {
    pub fn sg_init_pass(pass_id: sg_pass, desc: *const sg_pass_desc);
}
extern "C" {
    pub fn sg_uninit_buffer(buf_id: sg_buffer) -> bool;
}
extern "C" {
    pub fn sg_uninit_image(img_id: sg_image) -> bool;
}
extern "C" {
    pub fn sg_uninit_shader(shd_id: sg_shader) -> bool;
}
extern "C" {
    pub fn sg_uninit_pipeline(pip_id: sg_pipeline) -> bool;
}
extern "C" {
    pub fn sg_uninit_pass(pass_id: sg_pass) -> bool;
}
extern "C" {
    pub fn sg_fail_buffer(buf_id: sg_buffer);
}
extern "C" {
    pub fn sg_fail_image(img_id: sg_image);
}
extern "C" {
    pub fn sg_fail_shader(shd_id: sg_shader);
}
extern "C" {
    pub fn sg_fail_pipeline(pip_id: sg_pipeline);
}
extern "C" {
    pub fn sg_fail_pass(pass_id: sg_pass);
}
extern "C" {
    pub fn sg_setup_context() -> sg_context;
}
extern "C" {
    pub fn sg_activate_context(ctx_id: sg_context);
}
extern "C" {
    pub fn sg_discard_context(ctx_id: sg_context);
}
extern "C" {
    pub fn sg_d3d11_device() -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sg_mtl_device() -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn sg_mtl_render_command_encoder() -> *const ::std::os::raw::c_void;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
